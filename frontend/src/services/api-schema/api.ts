/* tslint:disable */
/* eslint-disable */
/**
 * arcadia-backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { RawAxiosRequestConfig } from 'axios';
import globalAxios from '../api/api';

export interface AddTitleGroupToSeries200Response {
    'data': TitleGroup;
    'side_effects': Array<SideEffect>;
}
export interface AddTitleGroupToSeriesRequest {
    'series_id': number;
    'title_group_id': number;
}
export interface AffiliatedArtistHierarchy {
    'artist': Artist;
    'artist_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'nickname'?: string | null;
    'roles': Array<ArtistRole>;
    'title_group_id': number;
}
export interface AffiliatedArtistLite {
    'artist_id': number;
    'name': string;
}
export interface AffiliatedEntityHierarchy {
    'created_at': string;
    'created_by_id': number;
    'entity': Entity;
    'entity_id': number;
    'id': number;
    'roles': Array<EntityRole>;
    'title_group_id': number;
}
export interface AppliedTitleGroupTag {
    'tag_id': number;
    'title_group_id': number;
}
export interface ArcadiaSettings {
    'allow_uploader_set_torrent_bonus_points_cost': boolean;
    'approved_image_hosts': Array<string>;
    'automated_message_on_signup'?: string | null;
    'automated_message_on_signup_conversation_name'?: string | null;
    'automated_message_on_signup_locked'?: boolean | null;
    'automated_message_on_signup_sender_id'?: number | null;
    'bonus_points_alias': string;
    'bonus_points_decimal_places': number;
    'bonus_points_given_on_upload': number;
    'bonus_points_per_endpoint': Array<BonusPointsEndpoint>;
    'default_css_sheet_name': string;
    'default_torrent_bonus_points_cost': number;
    'default_user_bonus_points_on_registration': number;
    'default_user_downloaded_on_registration': number;
    'default_user_freeleech_tokens_on_registration': number;
    'default_user_uploaded_on_registration': number;
    'display_image_host_drag_and_drop': boolean;
    'displayable_user_stats': Array<DisplayableUserStats>;
    'displayed_top_bar_stats': Array<DisplayedTopBarStats>;
    'global_download_factor': number;
    'global_upload_factor': number;
    'logo_subtitle'?: string | null;
    'open_signups': boolean;
    'shop_freeleech_token_base_price': number;
    'shop_freeleech_token_discount_tiers': any;
    'shop_upload_base_price_per_gb': number;
    'shop_upload_discount_tiers': any;
    'snatched_torrent_bonus_points_transferred_to'?: SnatchedTorrentBonusPointsTransferredTo | null;
    'torrent_bonus_points_cost_max': number;
    'torrent_bonus_points_cost_min': number;
    'torrent_max_release_date_allowed'?: string | null;
    'torrent_request_vote_currencies': Array<TorrentRequestVoteCurrency>;
    'upload_page_top_text'?: string | null;
    'user_class_name_on_signup': string;
}


export interface Artist {
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'edition_groups_amount': number;
    'id': number;
    'leechers_amount': number;
    'name': string;
    'pictures': Array<string>;
    'seeders_amount': number;
    'snatches_amount': number;
    'title_groups_amount': number;
    'torrents_amount': number;
}
export interface ArtistAndTitleGroupsLite {
    'artist': Artist;
    'title_groups': Array<TitleGroupHierarchyLite>;
}
export interface ArtistLite {
    'id': number;
    'name': string;
    'pictures': Array<string>;
}

export const ArtistRole = {
    Main: 'main',
    Guest: 'guest',
    Producer: 'producer',
    Director: 'director',
    Cinematographer: 'cinematographer',
    Actor: 'actor',
    Writer: 'writer',
    Composer: 'composer',
    Remixer: 'remixer',
    Conductor: 'conductor',
    DjCompiler: 'dj_compiler',
    Arranger: 'arranger',
    Host: 'host',
    Author: 'author',
    Illustrator: 'illustrator',
    Editor: 'editor',
    Developer: 'developer',
    Designer: 'designer',
    Creator: 'creator',
    Performer: 'performer',
    Presenter: 'presenter',
    Contributor: 'contributor'
} as const;

export type ArtistRole = typeof ArtistRole[keyof typeof ArtistRole];



export const ArtistSearchOrderByColumn = {
    Name: 'name',
    CreatedAt: 'created_at',
    TitleGroupsAmount: 'title_groups_amount'
} as const;

export type ArtistSearchOrderByColumn = typeof ArtistSearchOrderByColumn[keyof typeof ArtistSearchOrderByColumn];


export interface ArtistSearchResult {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'pictures': Array<string>;
    'title_groups_amount': number;
}

export const AudioBitrateSampling = {
    _64: '64',
    _128: '128',
    _192: '192',
    _256: '256',
    _320: '320',
    ApsVbr: 'APS (VBR)',
    V2Vbr: 'V2 (VBR)',
    V1Vbr: 'V1 (VBR)',
    ApxVbr: 'APX (VBR)',
    V0Vbr: 'V0 (VBR)',
    Lossless: 'Lossless',
    _24bitLossless: '24bit Lossless',
    Dsd64: 'DSD64',
    Dsd128: 'DSD128',
    Dsd256: 'DSD256',
    Dsd512: 'DSD512',
    Other: 'Other'
} as const;

export type AudioBitrateSampling = typeof AudioBitrateSampling[keyof typeof AudioBitrateSampling];



export const AudioChannels = {
    _10: '1.0',
    _20: '2.0',
    _21: '2.1',
    _50: '5.0',
    _51: '5.1',
    _71: '7.1'
} as const;

export type AudioChannels = typeof AudioChannels[keyof typeof AudioChannels];



export const AudioCodec = {
    Mp2: 'mp2',
    Mp3: 'mp3',
    Aac: 'aac',
    Ac3: 'ac3',
    Dts: 'dts',
    Flac: 'flac',
    Pcm: 'pcm',
    TrueHd: 'true-hd',
    Opus: 'opus',
    Dsd: 'dsd',
    Cook: 'cook'
} as const;

export type AudioCodec = typeof AudioCodec[keyof typeof AudioCodec];


export interface BonusPointsEndpoint {
    'amount': number;
    'method': HttpMethod;
    'path_prefix': string;
    'probability': number;
}


export interface BuyFreeleechTokens201Response {
    'data': ShopPurchase;
    'side_effects': Array<SideEffect>;
}
export interface BuyFreeleechTokensRequest {
    'quantity': number;
}
export interface BuyUploadRequest {
    'bytes': number;
}
export interface Collage {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
}



export const CollageCategory = {
    Personal: 'Personal',
    StaffPicks: 'Staff Picks',
    External: 'External',
    Theme: 'Theme'
} as const;

export type CollageCategory = typeof CollageCategory[keyof typeof CollageCategory];


export interface CollageEntry {
    'collage_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'note'?: string | null;
    'title_group_id': number;
}
export interface CollageLite {
    'cover'?: string | null;
    'id': number;
    'name': string;
}
export interface CollageSearchResult {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'description': string;
    'entries_amount': number;
    'id': number;
    'last_entry_at': string;
    'name': string;
    'tags': Array<string>;
}



export const ContentType = {
    Movie: 'movie',
    Video: 'video',
    TvShow: 'tv_show',
    Music: 'music',
    Podcast: 'podcast',
    Software: 'software',
    Book: 'book',
    Collection: 'collection'
} as const;

export type ContentType = typeof ContentType[keyof typeof ContentType];


export interface Conversation {
    'created_at': string;
    'id': number;
    'locked': boolean;
    'receiver_id': number;
    'receiver_last_seen_at': string;
    'sender_id': number;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationHierarchy {
    'created_at': string;
    'id': number;
    'locked': boolean;
    'messages': Array<ConversationMessageHierarchy>;
    'receiver': UserLiteAvatar;
    'receiver_last_seen_at': string;
    'sender': UserLiteAvatar;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationMessage {
    'content': string;
    'conversation_id': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
}
export interface ConversationMessageHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
}
export interface ConversationMessageHierarchyLite {
    'created_at': string;
    'created_by': UserLite;
}
export interface ConversationOverview {
    'correspondant': UserLite;
    'created_at': string;
    'id': number;
    'last_message': ConversationMessageHierarchyLite;
    'locked': boolean;
    'receiver_id': number;
    'receiver_last_seen_at': string;
    'sender_id': number;
    'sender_last_seen_at': string;
    'subject': string;
}
export interface ConversationsOverview {
    'conversations': Array<ConversationOverview>;
}
export interface CreateArtistAffiliation200Response {
    'data': Array<AffiliatedArtistHierarchy>;
    'side_effects': Array<SideEffect>;
}
export interface CreateArtists201Response {
    'data': Array<Artist>;
    'side_effects': Array<SideEffect>;
}
export interface CreateConversation200Response {
    'data': Conversation;
    'side_effects': Array<SideEffect>;
}
export interface CreateConversationMessage200Response {
    'data': ConversationMessage;
    'side_effects': Array<SideEffect>;
}
export interface CreateForumThread200Response {
    'data': ForumThread;
    'side_effects': Array<SideEffect>;
}
export interface CreateGift200Response {
    'data': Gift;
    'side_effects': Array<SideEffect>;
}
export interface CreateInvitation200Response {
    'data': Invitation;
    'side_effects': Array<SideEffect>;
}
export interface CreateMasterGroup200Response {
    'data': MasterGroup;
    'side_effects': Array<SideEffect>;
}
export interface CreateStaffPM201Response {
    'data': StaffPm;
    'side_effects': Array<SideEffect>;
}
export interface CreateStaffPMMessage201Response {
    'data': StaffPmMessage;
    'side_effects': Array<SideEffect>;
}
export interface CreateTitleGroupComment200Response {
    'data': TitleGroupComment;
    'side_effects': Array<SideEffect>;
}
export interface CreateTorrentReport200Response {
    'data': TorrentReport;
    'side_effects': Array<SideEffect>;
}
export interface CreateTorrentRequest200Response {
    'data': TorrentRequest;
    'side_effects': Array<SideEffect>;
}
export interface CreateTorrentRequestComment201Response {
    'data': TorrentRequestComment;
    'side_effects': Array<SideEffect>;
}
export interface CreateTorrentRequestVote200Response {
    'data': TorrentRequestVote;
    'side_effects': Array<SideEffect>;
}
export interface CreateUserApplication201Response {
    'data': UserApplication;
    'side_effects': Array<SideEffect>;
}
export interface CreateUserClass201Response {
    'data': UserClass;
    'side_effects': Array<SideEffect>;
}
export interface CssSheet {
    'created_at': string;
    'created_by_id': number;
    'css': string;
    'name': string;
    'preview_image_url': string;
}
export interface CssSheetsEnriched {
    'css_sheets': Array<CssSheet>;
    'default_sheet_name': string;
}
export interface DeleteArtistQuery {
    'artist_id': number;
}
export interface DeleteCollageEntriesQuery {
    'collage_id': number;
    'title_group_id': number;
}
export interface DeleteCollageQuery {
    'collage_id': number;
}
export interface DeleteForumCategoryQuery {
    'id': number;
}
export interface DeleteForumPostQuery {
    'id': number;
}
export interface DeleteForumSubCategoryQuery {
    'id': number;
}
export interface DeleteForumThreadQuery {
    'id': number;
}
export interface DeleteTagRequest {
    'id': number;
}
export interface DeleteTitleGroupQuery {
    'title_group_id': number;
}
export interface DeleteTorrentReportQuery {
    'torrent_report_id': number;
}
export interface DeleteUserClass {
    'target_class_name': string;
}
export interface DeletedDonation {
    'id': number;
}

export const DisplayableUserStats = {
    Uploaded: 'uploaded',
    RealUploaded: 'real_uploaded',
    Downloaded: 'downloaded',
    RealDownloaded: 'real_downloaded',
    Ratio: 'ratio',
    TitleGroups: 'title_groups',
    EditionGroups: 'edition_groups',
    Torrents: 'torrents',
    ForumPosts: 'forum_posts',
    ForumThreads: 'forum_threads',
    TitleGroupComments: 'title_group_comments',
    RequestComments: 'request_comments',
    ArtistComments: 'artist_comments',
    Seeding: 'seeding',
    Leeching: 'leeching',
    Snatched: 'snatched',
    SeedingSize: 'seeding_size',
    RequestsFilled: 'requests_filled',
    CollagesStarted: 'collages_started',
    RequestsVoted: 'requests_voted',
    AverageSeedingTime: 'average_seeding_time',
    Invited: 'invited',
    Invitations: 'invitations',
    BonusPoints: 'bonus_points',
    FreeleechTokens: 'freeleech_tokens',
    CurrentStreak: 'current_streak',
    HighestStreak: 'highest_streak'
} as const;

export type DisplayableUserStats = typeof DisplayableUserStats[keyof typeof DisplayableUserStats];



export const DisplayedTopBarStats = {
    Uploaded: 'uploaded',
    Downloaded: 'downloaded',
    Ratio: 'ratio',
    Torrents: 'torrents',
    ForumPosts: 'forum_posts',
    Seeding: 'seeding',
    Leeching: 'leeching',
    SeedingSize: 'seeding_size',
    AverageSeedingTime: 'average_seeding_time',
    BonusPoints: 'bonus_points',
    FreeleechTokens: 'freeleech_tokens',
    CurrentStreak: 'current_streak'
} as const;

export type DisplayedTopBarStats = typeof DisplayedTopBarStats[keyof typeof DisplayedTopBarStats];


export interface Donation {
    'amount': number;
    'created_at': string;
    'created_by_id': number;
    'donated_at': string;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}

export const DonationOrderBy = {
    DonatedAt: 'donated_at',
    CreatedAt: 'created_at',
    Amount: 'amount'
} as const;

export type DonationOrderBy = typeof DonationOrderBy[keyof typeof DonationOrderBy];


export interface DonationSearchResult {
    'amount': number;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'donated_at': string;
    'donated_by': UserLiteAvatar;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}
export interface EditArtist200Response {
    'data': Artist;
    'side_effects': Array<SideEffect>;
}
export interface EditCSSSheet200Response {
    'data': CssSheet;
    'side_effects': Array<SideEffect>;
}
export interface EditDonation200Response {
    'data': Donation;
    'side_effects': Array<SideEffect>;
}
export interface EditEditionGroup200Response {
    'data': EditionGroup;
    'side_effects': Array<SideEffect>;
}
export interface EditForumCategory200Response {
    'data': ForumCategory;
    'side_effects': Array<SideEffect>;
}
export interface EditForumPost200Response {
    'data': ForumPost;
    'side_effects': Array<SideEffect>;
}
export interface EditForumSubCategory200Response {
    'data': ForumSubCategory;
    'side_effects': Array<SideEffect>;
}
export interface EditTitleGroupTag200Response {
    'data': TitleGroupTag;
    'side_effects': Array<SideEffect>;
}
export interface EditTorrent200Response {
    'data': Torrent;
    'side_effects': Array<SideEffect>;
}
export interface EditTorrentUpDownFactors {
    'download_factor': number;
    'torrent_id': number;
    'upload_factor': number;
}
export interface EditedArtist {
    'description': string;
    'id': number;
    'name': string;
    'pictures': Array<string>;
}
export interface EditedCollage {
    'category': CollageCategory;
    'cover'?: string | null;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
}


export interface EditedCssSheet {
    'css': string;
    'name': string;
    'old_name': string;
    'preview_image_url': string;
}
export interface EditedDonation {
    'amount': number;
    'donated_at': string;
    'donated_by_id': number;
    'id': number;
    'note'?: string | null;
}
export interface EditedEditionGroup {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'id': number;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
}


export interface EditedForumCategory {
    'id': number;
    'name': string;
}
export interface EditedForumPost {
    'content': string;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
}
export interface EditedForumSubCategory {
    'id': number;
    'name': string;
    'new_threads_restricted': boolean;
}
export interface EditedForumThread {
    'forum_sub_category_id': number;
    'id': number;
    'name': string;
}
export interface EditedSeries {
    'banners': Array<string>;
    'covers': Array<string>;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
}
export interface EditedTitleGroup {
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'description': string;
    'external_links': Array<string>;
    'id': number;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'screenshots': Array<string>;
    'tagline'?: string | null;
    'trailers': Array<string>;
}


export interface EditedTitleGroupBookmark {
    'description'?: string | null;
    'id': number;
}
export interface EditedTitleGroupComment {
    'content': string;
    'locked': boolean;
}
export interface EditedTitleGroupTag {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface EditedTorrent {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'bonus_points_snatch_cost': number;
    'container': string;
    'description'?: string | null;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'id': number;
    'languages': Array<Language>;
    'mediainfo'?: string | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'subtitle_languages': Array<Language>;
    'trumpable'?: string | null;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface EditedUser {
    'avatar'?: string | null;
    'description': string;
    'email': string;
}
export interface EditedUserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'max_snatches_per_day'?: number | null;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'previous_user_class'?: string | null;
    'promotion_allowed_while_warned': boolean;
    'promotion_cost_bonus_points': number;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface EditedWikiArticle {
    'body': string;
    'id': number;
    'title': string;
}
export interface EditionGroup {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'id': number;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
    'title_group_id': number;
    'updated_at': string;
}


export interface EditionGroupHierarchy {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'id': number;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
    'title_group_id': number;
    'torrents': Array<TorrentHierarchy>;
    'updated_at': string;
}


export interface EditionGroupHierarchyLite {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'distributor'?: string | null;
    'id': number;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
    'title_group_id': number;
    'torrents': Array<TorrentHierarchyLite>;
}


export interface EditionGroupInfoLite {
    'additional_information': { [key: string]: string; };
    'distributor'?: string | null;
    'id': number;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
}


export interface Entity {
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'pictures': Array<string>;
}

export const EntityRole = {
    Producer: 'producer',
    Developer: 'developer',
    Designer: 'designer',
    Label: 'label',
    Network: 'network'
} as const;

export type EntityRole = typeof EntityRole[keyof typeof EntityRole];



export const ExternalDB = {
    Tmdb: 'tmdb'
} as const;

export type ExternalDB = typeof ExternalDB[keyof typeof ExternalDB];


export interface ExternalDBData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'edition_group'?: UserCreatedEditionGroup | null;
    'existing_title_group_id'?: number | null;
    'title_group'?: UserCreatedTitleGroup | null;
}

export const Extras = {
    Booklet: 'booklet',
    Manual: 'manual',
    BehindTheScenes: 'behind_the_scenes',
    DeletedScenes: 'deleted_scenes',
    Featurette: 'featurette',
    Trailer: 'trailer',
    Other: 'other'
} as const;

export type Extras = typeof Extras[keyof typeof Extras];



export const Features = {
    Hdr: 'HDR',
    Hdr10: 'HDR 10',
    Hdr102: 'HDR 10+',
    Dv: 'DV',
    Commentary: 'Commentary',
    Remux: 'Remux',
    _3D: '3D',
    Ocr: 'OCR',
    Cue: 'Cue'
} as const;

export type Features = typeof Features[keyof typeof Features];


export interface FillTorrentRequest200Response {
    'data': TorrentRequestFillResponse;
    'side_effects': Array<SideEffect>;
}
export interface ForumCategory {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
}
export interface ForumCategoryHierarchy {
    'id': number;
    'name': string;
    'sub_categories': Array<ForumSubCategoryHierarchy>;
}
export interface ForumCategoryLite {
    'id': number;
    'name': string;
}
export interface ForumOverview {
    'forum_categories': Array<ForumCategoryHierarchy>;
    'latest_posts_in_threads': Array<ForumSearchResult>;
}
export interface ForumPost {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumPostAndThreadName {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'forum_thread_id': number;
    'forum_thread_name': string;
    'id': number;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumPostHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface ForumSearchQuery {
    'page': number;
    'page_size': number;
    'thread_name'?: string | null;
}
export interface ForumSearchResult {
    'category_id': number;
    'category_name': string;
    'post': string;
    'post_created_at': string;
    'post_created_by_id': number;
    'post_created_by_username': string;
    'post_id': number;
    'sub_category_id': number;
    'sub_category_name': string;
    'thread_id': number;
    'thread_name': string;
}
export interface ForumSubCategory {
    'created_at': string;
    'created_by_id': number;
    'forbidden_classes': Array<string>;
    'forum_category_id': number;
    'id': number;
    'name': string;
    'new_threads_restricted': boolean;
    'posts_amount': number;
    'threads_amount': number;
}
export interface ForumSubCategoryAllowedPoster {
    'forum_sub_category_id': number;
    'user_id': number;
}
export interface ForumSubCategoryHierarchy {
    'category': ForumCategoryLite;
    'forbidden_classes': Array<string>;
    'id': number;
    'is_allowed_poster': boolean;
    'latest_post_in_thread'?: ForumThreadPostLite | null;
    'name': string;
    'new_threads_restricted': boolean;
    'posts_amount': number;
    'threads'?: Array<ForumThreadHierarchy> | null;
    'threads_amount': number;
}
export interface ForumThread {
    'created_at': string;
    'created_by_id': number;
    'forum_sub_category_id': number;
    'id': number;
    'locked': boolean;
    'name': string;
    'pinned': boolean;
    'posts_amount': number;
    'views_count': number;
}
export interface ForumThreadEnriched {
    'created_at': string;
    'created_by_id': number;
    'forum_category_id': number;
    'forum_category_name': string;
    'forum_sub_category_id': number;
    'forum_sub_category_name': string;
    'id': number;
    'is_subscribed': boolean;
    'locked': boolean;
    'name': string;
    'pinned': boolean;
    'posts_amount': number;
    'views_count': number;
}
export interface ForumThreadHierarchy {
    'created_at': string;
    'created_by': UserLite;
    'ever_opened': boolean;
    'has_new_posts': boolean;
    'id': number;
    'latest_post': ForumThreadPostLite;
    'locked': boolean;
    'name': string;
    'pinned': boolean;
    'posts_amount': number;
    'views_count': number;
}
export interface ForumThreadPostLite {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'thread_id': number;
}
export interface FreeleechTokenDiscountTier {
    'discount_percent': number;
    'threshold': number;
}
export interface FreeleechTokensPriceCalculation {
    'base_price': number;
    'discount_percent': number;
    'final_price': number;
    'quantity': number;
}
export interface GetAllUserClasses200Response {
    'data': Array<UserClass>;
    'side_effects': Array<SideEffect>;
}
export interface GetArcadiaSettings200Response {
    'data': ArcadiaSettings;
    'side_effects': Array<SideEffect>;
}
export interface GetArtistPublications200Response {
    'data': ArtistAndTitleGroupsLite;
    'side_effects': Array<SideEffect>;
}
export interface GetCSSSheets200Response {
    'data': CssSheetsEnriched;
    'side_effects': Array<SideEffect>;
}
export interface GetCollage200Response {
    'data': Collage;
    'side_effects': Array<SideEffect>;
}
export interface GetCollageEntries200Response {
    'data': PaginatedResultsTitleGroupHierarchyLite;
    'side_effects': Array<SideEffect>;
}
export interface GetComicVineData200Response {
    'data': ExternalDBData;
    'side_effects': Array<SideEffect>;
}
export interface GetConversation200Response {
    'data': ConversationHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface GetForum200Response {
    'data': ForumOverview;
    'side_effects': Array<SideEffect>;
}
export interface GetForumSubCategoryAllowedPosters200Response {
    'data': Array<UserLiteAvatar>;
    'side_effects': Array<SideEffect>;
}
export interface GetForumSubCategoryAllowedPostersQuery {
    'forum_sub_category_id': number;
}
export interface GetForumSubCategoryThreads200Response {
    'data': ForumSubCategoryHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface GetForumThread200Response {
    'data': ForumThreadEnriched;
    'side_effects': Array<SideEffect>;
}
export interface GetForumThreadPostsQuery {
    'page'?: number | null;
    'page_size': number;
    'post_id'?: number | null;
    'thread_id': number;
}
export interface GetForumThreadSPosts200Response {
    'data': PaginatedResultsForumPostHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface GetHomeData200Response {
    'data': HomePage;
    'side_effects': Array<SideEffect>;
}
export interface GetMe200Response {
    'data': Profile;
    'side_effects': Array<SideEffect>;
}
export interface GetNotificationsForForumThreadPosts200Response {
    'data': Array<NotificationForumThreadPost>;
    'side_effects': Array<SideEffect>;
}
export interface GetNotificationsForStaffPMMessages200Response {
    'data': Array<NotificationStaffPmMessage>;
    'side_effects': Array<SideEffect>;
}
export interface GetNotificationsForTitleGroupComments200Response {
    'data': Array<NotificationTitleGroupComment>;
    'side_effects': Array<SideEffect>;
}
export interface GetNotificationsForTorrentRequestComments200Response {
    'data': Array<NotificationTorrentRequestComment>;
    'side_effects': Array<SideEffect>;
}
export interface GetPublicArcadiaSettings200Response {
    'data': PublicArcadiaSettings;
    'side_effects': Array<SideEffect>;
}
export interface GetSeries200Response {
    'data': Series;
    'side_effects': Array<SideEffect>;
}
export interface GetShopPricing200Response {
    'data': ShopPricing;
    'side_effects': Array<SideEffect>;
}
export interface GetShopPurchaseHistory200Response {
    'data': Array<ShopPurchase>;
    'side_effects': Array<SideEffect>;
}
export interface GetStaffPM200Response {
    'data': StaffPmHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface GetTitleGroup200Response {
    'data': TitleGroupAndAssociatedData;
    'side_effects': Array<SideEffect>;
}
export interface GetTitleGroupBookmark200Response {
    'data': TitleGroupBookmark;
    'side_effects': Array<SideEffect>;
}
export interface GetTitleGroupInfoLite200Response {
    'data': TitleGroupLite;
    'side_effects': Array<SideEffect>;
}
export interface GetTopTorrent200Response {
    'data': PaginatedResultsTorrentHierarchyLite;
    'side_effects': Array<SideEffect>;
}
export interface GetTorrentActivitiesOverview200Response {
    'data': TorrentActivitiesOverview;
    'side_effects': Array<SideEffect>;
}
export interface GetTorrentPeers200Response {
    'data': Array<PublicPeer>;
    'side_effects': Array<SideEffect>;
}
export interface GetTorrentRequest200Response {
    'data': TorrentRequestAndAssociatedData;
    'side_effects': Array<SideEffect>;
}
export interface GetTorrentStats200Response {
    'data': TorrentStatsResponse;
    'side_effects': Array<SideEffect>;
}
export interface GetTorrentTitleGroupId200Response {
    'data': TorrentTitleGroupId;
    'side_effects': Array<SideEffect>;
}
export interface GetUploadInformation200Response {
    'data': UploadInformation;
    'side_effects': Array<SideEffect>;
}
export interface GetUser200Response {
    'data': PublicProfile;
    'side_effects': Array<SideEffect>;
}
export interface GetUserApplications200Response {
    'data': PaginatedResultsUserApplicationHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface GetUserApplicationsQuery {
    'page'?: number | null;
    'page_size'?: number | null;
    'status'?: UserApplicationStatus | null;
}


export interface GetUserConversations200Response {
    'data': ConversationsOverview;
    'side_effects': Array<SideEffect>;
}
export interface GetUserPermissions200Response {
    'data': Array<UserPermission>;
    'side_effects': Array<SideEffect>;
}
export interface GetUserSettings200Response {
    'data': UserSettings;
    'side_effects': Array<SideEffect>;
}
export interface GetUserTorrentActivities200Response {
    'data': PaginatedResultsTorrentActivityAndTitleGroup;
    'side_effects': Array<SideEffect>;
}
export interface GetWikiArticle200Response {
    'data': WikiArticle;
    'side_effects': Array<SideEffect>;
}
export interface Gift {
    'bonus_points': number;
    'freeleech_tokens': number;
    'id': number;
    'message': string;
    'receiver_id': number;
    'sender_id': number;
    'sent_at': string;
}
export interface HomePage {
    'bonus_points_alias': string;
    'latest_posts_in_threads': Array<ForumSearchResult>;
    'latest_title_group_comments': Array<TitleGroupCommentSearchResult>;
    'latest_uploads': Array<TitleGroupLite>;
    'recent_announcements': Array<ForumPostAndThreadName>;
    'stats': HomeStats;
}
export interface HomeStats {
    'artists': number;
    'collages': number;
    'enabled_users': number;
    'leechers': number;
    'peers': number;
    'seeders': number;
    'series': number;
    'snatches': number;
    'titles': number;
    'torrent_requests': number;
    'torrent_requests_filled': number;
    'torrents': number;
    'users_active_this_month': number;
    'users_active_this_week': number;
    'users_active_today': number;
}

export const HttpMethod = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Patch: 'PATCH',
    Delete: 'DELETE'
} as const;

export type HttpMethod = typeof HttpMethod[keyof typeof HttpMethod];


export interface InsertsEntriesIntoACollage200Response {
    'data': Array<CollageEntry>;
    'side_effects': Array<SideEffect>;
}
export interface Invitation {
    'created_at': string;
    'expires_at': string;
    'id': number;
    'invitation_key': string;
    'inviter_notes'?: string | null;
    'message': string;
    'receiver_email': string;
    'receiver_id'?: number | null;
    'sender_id': number;
    'user_application_id'?: number | null;
}
export interface InvitationHierarchy {
    'created_at': string;
    'expires_at': string;
    'id': number;
    'invitation_key': string;
    'inviter_notes'?: string | null;
    'message': string;
    'receiver'?: UserLiteAvatar | null;
    'receiver_email': string;
    'sender_id': number;
    'user_application_id'?: number | null;
}

export const InvitationSearchOrderByColumn = {
    CreatedAt: 'created_at',
    ReceiverUsername: 'receiver_username'
} as const;

export type InvitationSearchOrderByColumn = typeof InvitationSearchOrderByColumn[keyof typeof InvitationSearchOrderByColumn];



export const Language = {
    Albanian: 'Albanian',
    Arabic: 'Arabic',
    Belarusian: 'Belarusian',
    Bengali: 'Bengali',
    Bosnian: 'Bosnian',
    Bulgarian: 'Bulgarian',
    Cantonese: 'Cantonese',
    Catalan: 'Catalan',
    Chinese: 'Chinese',
    Croatian: 'Croatian',
    Czech: 'Czech',
    Danish: 'Danish',
    Dutch: 'Dutch',
    English: 'English',
    Estonian: 'Estonian',
    Finnish: 'Finnish',
    French: 'French',
    German: 'German',
    Greek: 'Greek',
    Hebrew: 'Hebrew',
    Hindi: 'Hindi',
    Hungarian: 'Hungarian',
    Icelandic: 'Icelandic',
    Indonesian: 'Indonesian',
    Italian: 'Italian',
    Japanese: 'Japanese',
    Kannada: 'Kannada',
    Korean: 'Korean',
    Macedonian: 'Macedonian',
    Malayalam: 'Malayalam',
    Mandarin: 'Mandarin',
    Nepali: 'Nepali',
    Norwegian: 'Norwegian',
    Persian: 'Persian',
    Polish: 'Polish',
    Portuguese: 'Portuguese',
    Romanian: 'Romanian',
    Russian: 'Russian',
    Serbian: 'Serbian',
    Spanish: 'Spanish',
    Swedish: 'Swedish',
    Tamil: 'Tamil',
    Tagalog: 'Tagalog',
    Telugu: 'Telugu',
    Thai: 'Thai',
    Turkish: 'Turkish',
    Ukrainian: 'Ukrainian',
    Vietnamese: 'Vietnamese',
    Wolof: 'Wolof',
    Other: 'Other'
} as const;

export type Language = typeof Language[keyof typeof Language];


export interface ListStaffPMs200Response {
    'data': Array<StaffPmOverview>;
    'side_effects': Array<SideEffect>;
}
export interface Login {
    'password': string;
    'remember_me': boolean;
    'username': string;
}
export interface Login200Response {
    'data': LoginResponse;
    'side_effects': Array<SideEffect>;
}
export interface LoginResponse {
    'refresh_token': string;
    'token': string;
}
export interface MasterGroup {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name'?: string | null;
    'updated_at': string;
}
export interface NotificationForumThreadPost {
    'created_at': string;
    'forum_post_id': number;
    'forum_thread_id': number;
    'forum_thread_name': string;
    'id': number;
    'read_status': boolean;
}
export interface NotificationStaffPmMessage {
    'created_at': string;
    'id': number;
    'read_status': boolean;
    'staff_pm_id': number;
    'staff_pm_message_id': number;
    'staff_pm_subject': string;
}
export interface NotificationTitleGroupComment {
    'created_at': string;
    'id': number;
    'read_status': boolean;
    'title_group_comment_id': number;
    'title_group_id': number;
    'title_group_name': string;
}
export interface NotificationTorrentRequestComment {
    'created_at': string;
    'id': number;
    'read_status': boolean;
    'title_group_name': string;
    'torrent_request_comment_id': number;
    'torrent_request_id': number;
}

export const OrderByDirection = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type OrderByDirection = typeof OrderByDirection[keyof typeof OrderByDirection];


export interface PaginatedResultsArtistSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsArtistSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsArtistSearchResultResultsInner {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'pictures': Array<string>;
    'title_groups_amount': number;
}
export interface PaginatedResultsCollageSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsCollageSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsCollageSearchResultResultsInner {
    'category': CollageCategory;
    'cover'?: string | null;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'description': string;
    'entries_amount': number;
    'id': number;
    'last_entry_at': string;
    'name': string;
    'tags': Array<string>;
}


export interface PaginatedResultsForumPostHierarchy {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsForumPostHierarchyResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsForumPostHierarchyResultsInner {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'forum_thread_id': number;
    'id': number;
    'locked': boolean;
    'sticky': boolean;
    'updated_at': string;
}
export interface PaginatedResultsForumSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsForumSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsForumSearchResultResultsInner {
    'category_id': number;
    'category_name': string;
    'post': string;
    'post_created_at': string;
    'post_created_by_id': number;
    'post_created_by_username': string;
    'post_id': number;
    'sub_category_id': number;
    'sub_category_name': string;
    'thread_id': number;
    'thread_name': string;
}
export interface PaginatedResultsInvitationHierarchy {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsInvitationHierarchyResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsInvitationHierarchyResultsInner {
    'created_at': string;
    'expires_at': string;
    'id': number;
    'invitation_key': string;
    'inviter_notes'?: string | null;
    'message': string;
    'receiver'?: UserLiteAvatar | null;
    'receiver_email': string;
    'sender_id': number;
    'user_application_id'?: number | null;
}
export interface PaginatedResultsTitleGroupCommentSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupCommentSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupCommentSearchResultResultsInner {
    'content': string;
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'title_group_id': number;
    'title_group_name': string;
}
export interface PaginatedResultsTitleGroupHierarchyLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupHierarchyLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupHierarchyLiteResultsInner {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupHierarchyLite>;
    'id': number;
    'name': string;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'series'?: SeriesLite | null;
    'tags': Array<string>;
}


export interface PaginatedResultsTitleGroupTagEnriched {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupTagEnrichedResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupTagEnrichedResultsInner {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
    'uses': number;
}
export interface PaginatedResultsTitleGroupTagLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTitleGroupTagLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTitleGroupTagLiteResultsInner {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface PaginatedResultsTorrentActivityAndTitleGroup {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTorrentActivityAndTitleGroupResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTorrentActivityAndTitleGroupResultsInner {
    'title_group': TitleGroupHierarchyLite;
    'torrent_activity': TorrentActivity;
}
export interface PaginatedResultsTorrentHierarchyLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTorrentHierarchyLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTorrentHierarchyLiteResultsInner {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'bonus_points_snatch_cost': number;
    'container': string;
    'created_at': string;
    'created_by'?: UserLite | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'grabbed': number;
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'upload_factor': number;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface PaginatedResultsTorrentRequestWithTitleGroupLite {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsTorrentRequestWithTitleGroupLiteResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsTorrentRequestWithTitleGroupLiteResultsInner {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'series'?: SeriesLite | null;
    'title_group': TitleGroupLite;
    'torrent_request': TorrentRequestHierarchyLite;
}
export interface PaginatedResultsUnauthorizedAccess {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUnauthorizedAccessResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUnauthorizedAccessResultsInner {
    'created_at': string;
    'id': number;
    'missing_permission': UserPermission;
    'path': string;
    'user': UserLiteAvatar;
}


export interface PaginatedResultsUserApplicationHierarchy {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUserApplicationHierarchyResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUserApplicationHierarchyResultsInner {
    'applied_from_ip': string;
    'body': string;
    'created_at': string;
    'email': string;
    'id': number;
    'referral': string;
    'staff_note': string;
    'status': UserApplicationStatus;
    'user'?: UserLite | null;
}


export interface PaginatedResultsUserEditChangeLogResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUserEditChangeLogResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUserEditChangeLogResultResultsInner {
    'edited_at': string;
    'edited_by': UserLiteAvatar;
    'edits': any;
    'id': number;
    'item_id': number;
    'item_type': string;
}
export interface PaginatedResultsUserSearchResult {
    'page': number;
    'page_size': number;
    'results': Array<PaginatedResultsUserSearchResultResultsInner>;
    'total_items': number;
}
export interface PaginatedResultsUserSearchResultResultsInner {
    'avatar'?: string | null;
    'banned': boolean;
    'class_name': string;
    'created_at': string;
    'downloaded': number;
    'forum_posts': number;
    'forum_threads': number;
    'id': number;
    'last_seen': string;
    'title_group_comments': number;
    'title_groups': number;
    'torrents': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}

export const PeerStatus = {
    Seeding: 'seeding',
    Leeching: 'leeching',
    Snatched: 'snatched',
    Grabbed: 'grabbed'
} as const;

export type PeerStatus = typeof PeerStatus[keyof typeof PeerStatus];


export interface PinForumThread {
    'pin': boolean;
    'thread_id': number;
}

export const Platform = {
    Windows: 'Windows',
    Linux: 'Linux',
    MacOs: 'MacOS',
    Xbox: 'Xbox'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


export interface Profile {
    'last_five_snatched_torrents': Array<TitleGroupHierarchyLite>;
    'last_five_uploaded_torrents': Array<TitleGroupHierarchyLite>;
    'torrent_clients': Array<TorrentClient>;
    'unread_announcements_amount': number;
    'unread_conversations_amount': number;
    'unread_notifications_amount_forum_thread_posts': number;
    'unread_notifications_amount_staff_pm_messages': number;
    'unread_notifications_amount_title_group_comments': number;
    'unread_notifications_amount_torrent_request_comments': number;
    'user': User;
    'user_warnings': Array<UserWarning>;
}
export interface PromotionPricing {
    'cost': number;
    'next_class_name': string;
    'requirements_met': boolean;
}
export interface PublicArcadiaSettings {
    'bonus_points_alias': string;
    'bonus_points_decimal_places': number;
    'display_image_host_drag_and_drop': boolean;
    'displayable_user_stats': Array<DisplayableUserStats>;
    'displayed_top_bar_stats': Array<DisplayedTopBarStats>;
    'emails_enabled': boolean;
    'global_download_factor': number;
    'global_upload_factor': number;
    'logo_subtitle'?: string | null;
    'open_signups': boolean;
    'torrent_request_vote_currencies': Array<TorrentRequestVoteCurrency>;
}
export interface PublicPeer {
    'agent': string;
    'downloaded': number;
    'ip'?: string | null;
    'left': number;
    'port'?: number | null;
    'seeder': boolean;
    'uploaded': number;
    'user': UserLite;
}
export interface PublicProfile {
    'last_five_snatched_torrents': Array<TitleGroupHierarchyLite>;
    'last_five_uploaded_torrents': Array<TitleGroupHierarchyLite>;
    'torrent_clients': Array<TorrentClient>;
    'user': PublicUser;
}
export interface PublicRating {
    'rating': number;
    'service': ExternalDB;
    'votes': number;
}


export interface PublicUser {
    'artist_comments': number;
    'avatar'?: string | null;
    'average_seeding_time': number;
    'banned': boolean;
    'bonus_points': number;
    'class_locked': boolean;
    'class_name': string;
    'collages_started': number;
    'created_at': string;
    'custom_title'?: string | null;
    'description': string;
    'downloaded': number;
    'edition_groups': number;
    'forum_posts': number;
    'forum_threads': number;
    'id': number;
    'invitations': number;
    'invited': number;
    'last_seen': string;
    'leeching': number;
    'real_downloaded': number;
    'real_uploaded': number;
    'request_comments': number;
    'requests_filled': number;
    'requests_voted': number;
    'seeding': number;
    'seeding_size': number;
    'snatched': number;
    'title_group_comments': number;
    'title_groups': number;
    'torrents': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}
export interface RefreshToken {
    'refresh_token': string;
}
export interface Register {
    'email': string;
    'password': string;
    'password_verify': string;
    'username': string;
}
export interface Register200Response {
    'data': User;
    'side_effects': Array<SideEffect>;
}
export interface RemoveAffiliatedArtistsForm {
    'affiliation_ids': Array<number>;
}
export interface RemoveTitleGroupFromSeriesRequest {
    'series_id': number;
    'title_group_id': number;
}
export interface RemovedTitleGroupTag {
    'tag_name': string;
    'title_group_id': number;
}
export interface SearchArtists200Response {
    'data': PaginatedResultsArtistSearchResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchArtistsLite200Response {
    'data': Array<ArtistLite>;
    'side_effects': Array<SideEffect>;
}
export interface SearchArtistsQuery {
    'name'?: string | null;
    'order_by_column': ArtistSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
}


export interface SearchCollages200Response {
    'data': PaginatedResultsCollageSearchResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchCollagesLite200Response {
    'data': Array<CollageLite>;
    'side_effects': Array<SideEffect>;
}
export interface SearchCollagesLiteQuery {
    'name': string;
    'results_amount': number;
}
export interface SearchCollagesQuery {
    'name'?: string | null;
    'page': number;
    'page_size': number;
    'tags'?: Array<string> | null;
}
export interface SearchDonations200Response {
    'data': SearchDonationsResponse;
    'side_effects': Array<SideEffect>;
}
export interface SearchDonationsQuery {
    'created_by_id'?: number | null;
    'donated_at_end'?: string | null;
    'donated_at_start'?: string | null;
    'donated_by_id'?: number | null;
    'max_amount'?: number | null;
    'min_amount'?: number | null;
    'order_by_column'?: DonationOrderBy;
    'order_by_direction'?: OrderByDirection;
    'page': number;
    'page_size': number;
}


export interface SearchDonationsResponse {
    'page': number;
    'page_size': number;
    'results': Array<DonationSearchResult>;
    'total_amount': number;
    'total_items': number;
    'unique_donors_count': number;
}
export interface SearchForum200Response {
    'data': PaginatedResultsForumSearchResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchSentInvitations200Response {
    'data': PaginatedResultsInvitationHierarchy;
    'side_effects': Array<SideEffect>;
}
export interface SearchSentInvitationsQuery {
    'order_by_column': InvitationSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'receiver_username'?: string | null;
}


export interface SearchSeries200Response {
    'data': SeriesSearchResponse;
    'side_effects': Array<SideEffect>;
}
export interface SearchSeriesLite200Response {
    'data': Array<SeriesLite>;
    'side_effects': Array<SideEffect>;
}
export interface SearchSeriesQuery {
    'name'?: string | null;
    'page': number;
    'page_size': number;
    'tags'?: Array<string> | null;
}
export interface SearchTitleGroupComments200Response {
    'data': PaginatedResultsTitleGroupCommentSearchResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchTitleGroupInfo200Response {
    'data': Array<TitleGroupLite>;
    'side_effects': Array<SideEffect>;
}
export interface SearchTitleGroupTags200Response {
    'data': PaginatedResultsTitleGroupTagEnriched;
    'side_effects': Array<SideEffect>;
}
export interface SearchTitleGroupTagsLite200Response {
    'data': PaginatedResultsTitleGroupTagLite;
    'side_effects': Array<SideEffect>;
}
export interface SearchTitleGroupTagsLiteQuery {
    'name': string;
    'page': number;
    'page_size': number;
}
export interface SearchTitleGroupTagsQuery {
    'name': string;
    'order_by_column': TitleGroupTagSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
}


export interface SearchTorrentRequests200Response {
    'data': PaginatedResultsTorrentRequestWithTitleGroupLite;
    'side_effects': Array<SideEffect>;
}
export interface SearchTorrentRequestsQuery {
    'include_filled': boolean;
    'order_by': TorrentRequestSearchOrderBy;
    'order_by_direction': OrderByDirection;
    'page'?: number | null;
    'page_size'?: number | null;
    'tags'?: Array<string> | null;
    'title_group_name'?: string | null;
}


export interface SearchUnauthorizedAccessLogs200Response {
    'data': PaginatedResultsUnauthorizedAccess;
    'side_effects': Array<SideEffect>;
}
export interface SearchUnauthorizedAccessQuery {
    'from_date': string;
    'page': number;
    'page_size': number;
    'permission'?: UserPermission | null;
    'sort_by_column': UnauthorizedAccessSortByColumn;
    'sort_by_direction': OrderByDirection;
    'to_date': string;
    'user_id'?: number | null;
}


export interface SearchUserEditChangeLogs200Response {
    'data': PaginatedResultsUserEditChangeLogResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchUserEditChangeLogsQuery {
    'item_type'?: string | null;
    'page': number;
    'page_size': number;
    'sort_by_column': UserEditChangeLogSortByColumn;
    'sort_by_direction': OrderByDirection;
    'user_id'?: number | null;
}


export interface SearchUsers200Response {
    'data': PaginatedResultsUserSearchResult;
    'side_effects': Array<SideEffect>;
}
export interface SearchUsersLite200Response {
    'data': Array<UserLite>;
    'side_effects': Array<SideEffect>;
}
export interface SearchUsersQuery {
    'order_by': UserSearchOrderBy;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'username'?: string | null;
}



export const SeedersPerTorrent = {
    Current: 'current',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _10: '10',
    _15: '15',
    _20: '20',
    _25: '25',
    _50: '50',
    _100: '100',
    _10Percent: '10_percent',
    _25Percent: '25_percent',
    _50Percent: '50_percent',
    _75Percent: '75_percent',
    _100Percent: '100_percent',
    _150Percent: '150_percent',
    _200Percent: '200_percent',
    _300Percent: '300_percent',
    _500Percent: '500_percent'
} as const;

export type SeedersPerTorrent = typeof SeedersPerTorrent[keyof typeof SeedersPerTorrent];


export interface SentInvitation {
    'inviter_notes'?: string | null;
    'message': string;
    'receiver_email': string;
    'user_application_id'?: number | null;
}
export interface Series {
    'banners'?: Array<string> | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'id': number;
    'name': string;
    'tags': Array<string>;
    'updated_at': string;
}
export interface SeriesLite {
    'id': number;
    'name': string;
}
export interface SeriesSearchResponse {
    'results': Array<SeriesSearchResult>;
    'total_items': number;
}
export interface SeriesSearchResult {
    'banners'?: Array<string> | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'tags': Array<string>;
    'title_groups_amount': number;
}
export interface SetTorrentStaffChecked {
    'staff_checked': boolean;
    'torrent_id': number;
}

export const ShopItem = {
    Promotion: 'Promotion',
    Upload: 'Upload',
    FreeleechTokens: 'FreeleechTokens'
} as const;

export type ShopItem = typeof ShopItem[keyof typeof ShopItem];


export interface ShopPricing {
    'freeleech_token_base_price': number;
    'freeleech_token_discount_tiers': Array<FreeleechTokenDiscountTier>;
    'promotion'?: PromotionPricing | null;
    'upload_base_price_per_gb': number;
    'upload_discount_tiers': Array<UploadDiscountTier>;
}
export interface ShopPurchase {
    'bonus_points_spent': number;
    'extra_info'?: string | null;
    'id': number;
    'item_type': ShopItem;
    'purchased_at': string;
    'quantity': number;
    'user_id': number;
}


export interface SideEffect {
    'amount': number;
    'type': SideEffectTypeEnum;
}

export const SideEffectTypeEnum = {
    BonusPoints: 'bonus_points'
} as const;

export type SideEffectTypeEnum = typeof SideEffectTypeEnum[keyof typeof SideEffectTypeEnum];


export const SnatchedTorrentBonusPointsTransferredTo = {
    Uploader: 'uploader',
    CurrentSeeders: 'current_seeders'
} as const;

export type SnatchedTorrentBonusPointsTransferredTo = typeof SnatchedTorrentBonusPointsTransferredTo[keyof typeof SnatchedTorrentBonusPointsTransferredTo];



export const Source = {
    Cd: 'CD',
    Vinyl: 'Vinyl',
    Web: 'Web',
    Soundboard: 'Soundboard',
    Sacd: 'SACD',
    Dat: 'DAT',
    Cassette: 'Cassette',
    BluRay: 'Blu-Ray',
    LaserDisc: 'LaserDisc',
    HdDvd: 'HD-DVD',
    Hdtv: 'HDTV',
    Pdtv: 'PDTV',
    Tv: 'TV',
    Vhs: 'VHS',
    Mixed: 'Mixed',
    PhysicalBook: 'Physical Book',
    Dvd: 'DVD'
} as const;

export type Source = typeof Source[keyof typeof Source];


export interface StaffPm {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'resolved': boolean;
    'subject': string;
}
export interface StaffPmHierarchy {
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
    'messages': Array<StaffPmMessageHierarchy>;
    'resolved': boolean;
    'subject': string;
}
export interface StaffPmMessage {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'staff_pm_id': number;
}
export interface StaffPmMessageHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'id': number;
}
export interface StaffPmMessageHierarchyLite {
    'created_at': string;
    'created_by': UserLite;
}
export interface StaffPmOverview {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'last_message': StaffPmMessageHierarchyLite;
    'resolved': boolean;
    'subject': string;
}

export const StatsInterval = {
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type StatsInterval = typeof StatsInterval[keyof typeof StatsInterval];


export interface TitleGroup {
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description': string;
    'external_links': Array<string>;
    'id': number;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'public_ratings': Array<PublicRating>;
    'screenshots': Array<string>;
    'series_id'?: number | null;
    'tagline'?: string | null;
    'tags': Array<string>;
    'trailers': Array<string>;
    'updated_at': string;
}


export interface TitleGroupAndAssociatedData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'affiliated_entities': Array<AffiliatedEntityHierarchy>;
    'collages': Array<CollageSearchResult>;
    'edition_groups': Array<EditionGroupHierarchy>;
    'in_same_master_group': Array<TitleGroupLite>;
    'is_subscribed_to_comments': boolean;
    'is_subscribed_to_torrents': boolean;
    'series': SeriesLite;
    'title_group': TitleGroup;
    'title_group_comments': Array<TitleGroupCommentHierarchy>;
    'torrent_requests': Array<TorrentRequestHierarchyLite>;
}
export interface TitleGroupBookmark {
    'created_at': string;
    'description'?: string | null;
    'id': number;
    'title_group_id': number;
    'user_id': number;
}

export const TitleGroupCategory = {
    Ep: 'Ep',
    Album: 'Album',
    Single: 'Single',
    Soundtrack: 'Soundtrack',
    Anthology: 'Anthology',
    Compilation: 'Compilation',
    Remix: 'Remix',
    Bootleg: 'Bootleg',
    Mixtape: 'Mixtape',
    ConcertRecording: 'ConcertRecording',
    DjMix: 'DjMix',
    FeatureFilm: 'FeatureFilm',
    ShortFilm: 'ShortFilm',
    Game: 'Game',
    Program: 'Program',
    Illustrated: 'Illustrated',
    Periodical: 'Periodical',
    Book: 'Book',
    Article: 'Article',
    Manual: 'Manual',
    Other: 'Other'
} as const;

export type TitleGroupCategory = typeof TitleGroupCategory[keyof typeof TitleGroupCategory];


export interface TitleGroupComment {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'locked': boolean;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
    'updated_at': string;
}
export interface TitleGroupCommentHierarchy {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'id': number;
    'locked': boolean;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
    'updated_at': string;
}
export interface TitleGroupCommentSearchQuery {
    'content'?: string | null;
    'page': number;
    'page_size': number;
}
export interface TitleGroupCommentSearchResult {
    'content': string;
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'title_group_id': number;
    'title_group_name': string;
}
export interface TitleGroupHierarchyLite {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupHierarchyLite>;
    'id': number;
    'name': string;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'series'?: SeriesLite | null;
    'tags': Array<string>;
}


export interface TitleGroupLite {
    'content_type': ContentType;
    'covers': Array<string>;
    'edition_groups': Array<EditionGroupInfoLite>;
    'id': number;
    'latest_torrent_uploaded_at'?: string | null;
    'latest_torrent_uploaded_by'?: UserLite | null;
    'name': string;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'series'?: SeriesLite | null;
}


export interface TitleGroupTag {
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}
export interface TitleGroupTagEnriched {
    'created_at': string;
    'created_by': UserLite;
    'id': number;
    'name': string;
    'synonyms': Array<string>;
    'uses': number;
}
export interface TitleGroupTagLite {
    'id': number;
    'name': string;
    'synonyms': Array<string>;
}

export const TitleGroupTagSearchOrderByColumn = {
    CreatedAt: 'created_at',
    Uses: 'uses',
    Name: 'name'
} as const;

export type TitleGroupTagSearchOrderByColumn = typeof TitleGroupTagSearchOrderByColumn[keyof typeof TitleGroupTagSearchOrderByColumn];


export interface Torrent {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'bonus_points_snatch_cost': number;
    'container': string;
    'created_at': string;
    'created_by_id': number;
    'deleted_at': string;
    'deleted_by_id'?: number | null;
    'description'?: string | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'file_amount_per_type': { [key: string]: string; };
    'file_list': { [key: string]: string; };
    'grabbed': number;
    'id': number;
    'info_hash': Array<number>;
    'languages': Array<Language>;
    'leechers': number;
    'mediainfo'?: string | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'seeders': number;
    'size': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'updated_at': string;
    'upload_factor': number;
    'upload_method': string;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentActivitiesOverview {
    'bonus_points_formula': string;
    'bonus_points_per_day': number;
    'bonus_points_update_interval_seconds': number;
}
export interface TorrentActivity {
    'bonus_points': number;
    'bonus_points_per_day': number;
    'completed_at'?: string | null;
    'downloaded': number;
    'first_seen_seeding_at'?: string | null;
    'grabbed_at'?: string | null;
    'id': number;
    'last_seen_seeding_at'?: string | null;
    'real_downloaded': number;
    'real_uploaded': number;
    'seeder': boolean;
    'torrent_id': number;
    'total_seed_time': number;
    'uploaded': number;
    'user_id': number;
}
export interface TorrentActivityAndTitleGroup {
    'title_group': TitleGroupHierarchyLite;
    'torrent_activity': TorrentActivity;
}

export const TorrentActivityOrderByColumn = {
    GrabbedAt: 'grabbed_at',
    TotalSeedTime: 'total_seed_time',
    Uploaded: 'uploaded',
    Downloaded: 'downloaded',
    TorrentSize: 'torrent_size',
    TorrentSeeders: 'torrent_seeders',
    BonusPoints: 'bonus_points',
    BonusPointsPerDay: 'bonus_points_per_day'
} as const;

export type TorrentActivityOrderByColumn = typeof TorrentActivityOrderByColumn[keyof typeof TorrentActivityOrderByColumn];


export interface TorrentClient {
    'agent': string;
    'first_seen_at': string;
    'ip': string;
    'last_seen_at': string;
    'port': number;
    'real_downloaded': number;
    'real_uploaded': number;
}
export interface TorrentHierarchy {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'bonus_points_snatch_cost': number;
    'container': string;
    'created_at': string;
    'created_by'?: UserLite | null;
    'created_by_id'?: number | null;
    'description'?: string | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'file_amount_per_type': { [key: string]: string; };
    'file_list': { [key: string]: string; };
    'grabbed': number;
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'mediainfo'?: string | null;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'updated_at': string;
    'upload_factor': number;
    'uploaded_as_anonymous': boolean;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentHierarchyLite {
    'audio_bitrate'?: number | null;
    'audio_bitrate_sampling'?: AudioBitrateSampling | null;
    'audio_channels'?: AudioChannels | null;
    'audio_codec'?: AudioCodec | null;
    'bonus_points_snatch_cost': number;
    'container': string;
    'created_at': string;
    'created_by'?: UserLite | null;
    'download_factor': number;
    'duration'?: number | null;
    'edition_group_id': number;
    'extras': Array<Extras>;
    'features': Array<Features>;
    'grabbed': number;
    'id': number;
    'languages': Array<Language>;
    'leechers': number;
    'peer_status'?: PeerStatus | null;
    'release_group'?: string | null;
    'release_name'?: string | null;
    'reports': Array<TorrentReport>;
    'seeders': number;
    'size': number;
    'staff_checked': boolean;
    'subtitle_languages': Array<Language>;
    'times_completed': number;
    'trumpable'?: string | null;
    'upload_factor': number;
    'video_codec'?: VideoCodec | null;
    'video_resolution'?: VideoResolution | null;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}


export interface TorrentReport {
    'description': string;
    'id': number;
    'reported_at': string;
    'reported_by_id': number;
    'reported_torrent_id': number;
}
export interface TorrentRequest {
    'audio_bitrate_sampling': Array<AudioBitrateSampling>;
    'audio_channels': Array<AudioChannels>;
    'audio_codec': Array<AudioCodec>;
    'container': Array<string>;
    'created_at': string;
    'created_by_id': number;
    'description'?: string | null;
    'edition_name'?: string | null;
    'features': Array<Features>;
    'filled_at': string;
    'filled_by_torrent_id'?: number | null;
    'filled_by_user_id'?: number | null;
    'id': number;
    'languages': Array<Language>;
    'release_group'?: string | null;
    'source': Array<Source>;
    'subtitle_languages': Array<Language>;
    'title_group_id': number;
    'updated_at': string;
    'video_codec': Array<VideoCodec>;
    'video_resolution': Array<VideoResolution>;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}
export interface TorrentRequestAndAssociatedData {
    'affiliated_artists': Array<AffiliatedArtistHierarchy>;
    'comments': Array<TorrentRequestCommentHierarchy>;
    'filled_by_user'?: UserLite | null;
    'is_subscribed_to_comments': boolean;
    'series': SeriesLite;
    'title_group': TitleGroup;
    'torrent_request': TorrentRequest;
    'votes': Array<TorrentRequestVoteHierarchy>;
}
export interface TorrentRequestBounty {
    'bonus_points': number;
    'upload': number;
}
export interface TorrentRequestComment {
    'content': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
    'updated_at': string;
}
export interface TorrentRequestCommentHierarchy {
    'content': string;
    'created_at': string;
    'created_by': UserLiteAvatar;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
    'updated_at': string;
}
export interface TorrentRequestFill {
    'torrent_id': number;
    'torrent_request_id': number;
}
export interface TorrentRequestFillResponse {
    'filler_is_uploader': boolean;
}
export interface TorrentRequestHierarchyLite {
    'bounty': TorrentRequestBounty;
    'created_by': UserLite;
    'filled_by'?: UserLite | null;
    'torrent_request': TorrentRequest;
    'user_votes_amount': number;
}

export const TorrentRequestSearchOrderBy = {
    Upload: 'upload',
    BonusPoints: 'bonus_points',
    Voters: 'voters',
    CreatedAt: 'created_at'
} as const;

export type TorrentRequestSearchOrderBy = typeof TorrentRequestSearchOrderBy[keyof typeof TorrentRequestSearchOrderBy];


export interface TorrentRequestVote {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
}

export const TorrentRequestVoteCurrency = {
    Upload: 'upload',
    BonusPoints: 'bonus_points'
} as const;

export type TorrentRequestVoteCurrency = typeof TorrentRequestVoteCurrency[keyof typeof TorrentRequestVoteCurrency];


export interface TorrentRequestVoteHierarchy {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'created_at': string;
    'created_by': UserLite;
    'created_by_id': number;
    'id': number;
    'torrent_request_id': number;
}
export interface TorrentRequestWithTitleGroupLite {
    'affiliated_artists': Array<AffiliatedArtistLite>;
    'series'?: SeriesLite | null;
    'title_group': TitleGroupLite;
    'torrent_request': TorrentRequestHierarchyLite;
}
export interface TorrentSearch {
    'artist_id'?: number | null;
    'collage_id'?: number | null;
    'edition_group_source'?: Array<Source>;
    'order_by_column': TorrentSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'series_id'?: number | null;
    'title_group_category'?: Array<TitleGroupCategory>;
    'title_group_content_type'?: Array<ContentType>;
    'title_group_include_empty_groups': boolean;
    'title_group_name'?: string | null;
    'torrent_created_by_id'?: number | null;
    'torrent_language'?: Array<Language>;
    'torrent_reported'?: boolean | null;
    'torrent_snatched_by_id'?: number | null;
    'torrent_staff_checked'?: boolean | null;
    'torrent_video_resolution'?: Array<VideoResolution>;
}



export const TorrentSearchOrderByColumn = {
    TorrentCreatedAt: 'torrent_created_at',
    TorrentSize: 'torrent_size',
    TorrentSnatchedAt: 'torrent_snatched_at',
    TitleGroupOriginalReleaseDate: 'title_group_original_release_date',
    TorrentSeeders: 'torrent_seeders',
    TorrentLeechers: 'torrent_leechers',
    TorrentSnatched: 'torrent_snatched'
} as const;

export type TorrentSearchOrderByColumn = typeof TorrentSearchOrderByColumn[keyof typeof TorrentSearchOrderByColumn];


export interface TorrentStatsDataPoint {
    'attribute_value'?: string | null;
    'count': number;
    'period': string;
    'total_size': number;
}

export const TorrentStatsGroupBy = {
    None: 'none',
    VideoResolution: 'video_resolution',
    VideoCodec: 'video_codec',
    AudioCodec: 'audio_codec',
    AudioChannels: 'audio_channels',
    AudioBitrateSampling: 'audio_bitrate_sampling',
    Container: 'container',
    Source: 'source',
    ContentType: 'content_type',
    Category: 'category',
    Platform: 'platform',
    OriginalLanguage: 'original_language',
    CountryFrom: 'country_from'
} as const;

export type TorrentStatsGroupBy = typeof TorrentStatsGroupBy[keyof typeof TorrentStatsGroupBy];


export interface TorrentStatsResponse {
    'data': Array<TorrentStatsDataPoint>;
    'unique_uploaders': number;
}
export interface TorrentTitleGroupId {
    'title_group_id': number;
}
export interface TorrentToDelete {
    'displayed_reason'?: string | null;
    'id': number;
    'reason': string;
}
export interface UnauthorizedAccess {
    'created_at': string;
    'id': number;
    'missing_permission': UserPermission;
    'path': string;
    'user': UserLiteAvatar;
}



export const UnauthorizedAccessSortByColumn = {
    CreatedAt: 'created_at',
    MissingPermission: 'missing_permission'
} as const;

export type UnauthorizedAccessSortByColumn = typeof UnauthorizedAccessSortByColumn[keyof typeof UnauthorizedAccessSortByColumn];


export interface UpdateUserApplication {
    'status': UserApplicationStatus;
    'user_application_id': number;
}


export interface UpdateUserCustomTitle {
    'custom_title'?: string | null;
}
export interface UpdatedUserPermissions {
    'permissions': Array<UserPermission>;
}
export interface UploadDiscountTier {
    'discount_percent': number;
    'threshold_gb': number;
}
export interface UploadImage200Response {
    'data': UploadImageResponse;
    'side_effects': Array<SideEffect>;
}
export interface UploadImageForm {
    'image': File;
}
export interface UploadImageResponse {
    'url': string;
}
export interface UploadInformation {
    'allow_uploader_set_torrent_bonus_points_cost': boolean;
    'announce_url': string;
    'bonus_points_given_on_upload': number;
    'default_torrent_bonus_points_cost': number;
    'upload_page_top_text'?: string | null;
}
export interface UploadPriceCalculation {
    'base_price': number;
    'bytes': number;
    'discount_percent': number;
    'final_price': number;
}
export interface UploadedTorrent {
    'audio_bitrate': number;
    'audio_bitrate_sampling': AudioBitrateSampling;
    'audio_channels': string;
    'audio_codec': AudioCodec;
    'bonus_points_snatch_cost': number;
    'container': string;
    'description': string;
    'duration': number;
    'edition_group_id': number;
    'extras': string;
    'features': string;
    'languages': string;
    'mediainfo': string;
    'release_group': string;
    'release_name': string;
    'subtitle_languages': string;
    'torrent_file': File;
    'trumpable': string;
    'uploaded_as_anonymous': boolean;
    'video_codec': VideoCodec;
    'video_resolution': VideoResolution;
    'video_resolution_other_x': number;
    'video_resolution_other_y': number;
}


export interface User {
    'artist_comments': number;
    'avatar'?: string | null;
    'average_seeding_time': number;
    'banned': boolean;
    'bonus_points': number;
    'class_locked': boolean;
    'class_name': string;
    'collages_started': number;
    'created_at': string;
    'css_sheet_name': string;
    'current_streak': number;
    'custom_title'?: string | null;
    'description': string;
    'downloaded': number;
    'edition_groups': number;
    'email': string;
    'forum_posts': number;
    'forum_threads': number;
    'freeleech_tokens': number;
    'highest_streak': number;
    'id': number;
    'invitations': number;
    'invited': number;
    'last_seen': string;
    'leeching': number;
    'max_snatches_per_day'?: number | null;
    'passkey': string;
    'password_hash': string;
    'permissions': Array<UserPermission>;
    'real_downloaded': number;
    'real_uploaded': number;
    'registered_from_ip': string;
    'request_comments': number;
    'requests_filled': number;
    'requests_voted': number;
    'seeding': number;
    'seeding_size': number;
    'snatched': number;
    'staff_note': string;
    'title_group_comments': number;
    'title_groups': number;
    'torrents': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}
export interface UserApplication {
    'applied_from_ip': string;
    'body': string;
    'created_at': string;
    'email': string;
    'id': number;
    'referral': string;
    'staff_note': string;
    'status': UserApplicationStatus;
}


export interface UserApplicationHierarchy {
    'applied_from_ip': string;
    'body': string;
    'created_at': string;
    'email': string;
    'id': number;
    'referral': string;
    'staff_note': string;
    'status': UserApplicationStatus;
    'user'?: UserLite | null;
}



export const UserApplicationStatus = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type UserApplicationStatus = typeof UserApplicationStatus[keyof typeof UserApplicationStatus];


export interface UserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'max_snatches_per_day'?: number | null;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'previous_user_class'?: string | null;
    'promotion_allowed_while_warned': boolean;
    'promotion_cost_bonus_points': number;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface UserClassChange {
    'class_name': string;
}
export interface UserClassLockStatus {
    'class_locked': boolean;
}
export interface UserCreatedAffiliatedArtist {
    'artist_id': number;
    'nickname'?: string | null;
    'roles': Array<ArtistRole>;
    'title_group_id': number;
}
export interface UserCreatedArtist {
    'description': string;
    'name': string;
    'pictures': Array<string>;
}
export interface UserCreatedCollage {
    'category': CollageCategory;
    'cover'?: string | null;
    'description': string;
    'name': string;
    'tags': Array<string>;
}


export interface UserCreatedCollageEntry {
    'collage_id': number;
    'note'?: string | null;
    'title_group_id': number;
}
export interface UserCreatedConversation {
    'first_message': UserCreatedConversationMessage;
    'receiver_id': number;
    'subject': string;
}
export interface UserCreatedConversationMessage {
    'content': string;
    'conversation_id': number;
}
export interface UserCreatedCssSheet {
    'css': string;
    'name': string;
    'preview_image_url': string;
}
export interface UserCreatedDonation {
    'amount': number;
    'donated_at'?: string | null;
    'donated_by_id': number;
    'note'?: string | null;
}
export interface UserCreatedEditionGroup {
    'additional_information': { [key: string]: string; };
    'covers': Array<string>;
    'description'?: string | null;
    'distributor'?: string | null;
    'external_links': Array<string>;
    'name'?: string | null;
    'release_date': string | null;
    'release_date_only_year_known': boolean;
    'source'?: Source | null;
    'title_group_id': number;
}


export interface UserCreatedForumCategory {
    'name': string;
}
export interface UserCreatedForumPost {
    'content': string;
    'forum_thread_id': number;
}
export interface UserCreatedForumSubCategory {
    'forum_category_id': number;
    'name': string;
}
export interface UserCreatedForumThread {
    'first_post': UserCreatedForumPost;
    'forum_sub_category_id': number;
    'name': string;
}
export interface UserCreatedGift {
    'bonus_points': number;
    'freeleech_tokens': number;
    'message': string;
    'receiver_id': number;
}
export interface UserCreatedMasterGroup {
    'name'?: string | null;
}
export interface UserCreatedSeries {
    'banners': Array<string>;
    'covers': Array<string>;
    'description': string;
    'name': string;
    'tags': Array<string>;
}
export interface UserCreatedStaffPm {
    'first_message': UserCreatedStaffPmMessage;
    'subject': string;
}
export interface UserCreatedStaffPmMessage {
    'content': string;
    'staff_pm_id': number;
}
export interface UserCreatedTitleGroup {
    'affiliated_artists': Array<UserCreatedAffiliatedArtist>;
    'category'?: TitleGroupCategory | null;
    'content_type': ContentType;
    'country_from'?: string | null;
    'covers': Array<string>;
    'description': string;
    'external_links': Array<string>;
    'master_group_id'?: number | null;
    'name': string;
    'name_aliases': Array<string>;
    'original_language'?: Language | null;
    'original_release_date': string | null;
    'original_release_date_only_year_known': boolean;
    'platform'?: Platform | null;
    'screenshots': Array<string>;
    'series_id'?: number | null;
    'tagline'?: string | null;
    'tags': Array<string>;
    'trailers': Array<string>;
}


export interface UserCreatedTitleGroupBookmark {
    'description'?: string | null;
    'title_group_id': number;
}
export interface UserCreatedTitleGroupComment {
    'answers_to_comment_id'?: number | null;
    'content': string;
    'refers_to_torrent_id'?: number | null;
    'title_group_id': number;
}
export interface UserCreatedTitleGroupTag {
    'name': string;
}
export interface UserCreatedTorrentReport {
    'description': string;
    'reported_torrent_id': number;
}
export interface UserCreatedTorrentRequest {
    'audio_bitrate_sampling': Array<AudioBitrateSampling>;
    'audio_channels': Array<AudioChannels>;
    'audio_codec': Array<AudioCodec>;
    'container': Array<string>;
    'description'?: string | null;
    'edition_name'?: string | null;
    'features': Array<Features>;
    'initial_vote': UserCreatedTorrentRequestVote;
    'languages': Array<Language>;
    'release_group'?: string | null;
    'source': Array<Source>;
    'subtitle_languages': Array<Language>;
    'title_group_id': number;
    'video_codec': Array<VideoCodec>;
    'video_resolution': Array<VideoResolution>;
    'video_resolution_other_x'?: number | null;
    'video_resolution_other_y'?: number | null;
}
export interface UserCreatedTorrentRequestComment {
    'content': string;
    'torrent_request_id': number;
}
export interface UserCreatedTorrentRequestVote {
    'bounty_bonus_points': number;
    'bounty_upload': number;
    'torrent_request_id': number;
}
export interface UserCreatedUserApplication {
    'body': string;
    'email': string;
    'referral': string;
}
export interface UserCreatedUserClass {
    'automatic_demotion': boolean;
    'automatic_promotion': boolean;
    'max_snatches_per_day'?: number | null;
    'name': string;
    'new_permissions': Array<UserPermission>;
    'previous_user_class'?: string | null;
    'promotion_allowed_while_warned': boolean;
    'promotion_cost_bonus_points': number;
    'required_account_age_in_days': number;
    'required_downloaded': number;
    'required_forum_posts': number;
    'required_forum_posts_in_unique_threads': number;
    'required_ratio': number;
    'required_seeding_size': number;
    'required_title_group_comments': number;
    'required_torrent_snatched': number;
    'required_torrent_uploads': number;
    'required_torrent_uploads_in_unique_title_groups': number;
    'required_uploaded': number;
}
export interface UserCreatedUserWarning {
    'ban': boolean;
    'expires_at'?: string | null;
    'reason': string;
    'user_id': number;
}
export interface UserCreatedWikiArticle {
    'body': string;
    'title': string;
}
export interface UserEditChangeLogResult {
    'edited_at': string;
    'edited_by': UserLiteAvatar;
    'edits': any;
    'id': number;
    'item_id': number;
    'item_type': string;
}

export const UserEditChangeLogSortByColumn = {
    EditedAt: 'edited_at'
} as const;

export type UserEditChangeLogSortByColumn = typeof UserEditChangeLogSortByColumn[keyof typeof UserEditChangeLogSortByColumn];


export interface UserLite {
    'banned': boolean;
    'id': number;
    'username': string;
    'warned': boolean;
}
export interface UserLiteAvatar {
    'avatar'?: string | null;
    'banned': boolean;
    'class_name': string;
    'custom_title'?: string | null;
    'id': number;
    'username': string;
    'warned': boolean;
}

export const UserPermission = {
    UploadTorrent: 'upload_torrent',
    DownloadTorrent: 'download_torrent',
    CreateTorrentRequest: 'create_torrent_request',
    ImmuneActivityPruning: 'immune_activity_pruning',
    EditTitleGroup: 'edit_title_group',
    EditTitleGroupComment: 'edit_title_group_comment',
    EditEditionGroup: 'edit_edition_group',
    EditTorrent: 'edit_torrent',
    EditArtist: 'edit_artist',
    DeleteArtist: 'delete_artist',
    DeleteTitleGroup: 'delete_title_group',
    EditCollage: 'edit_collage',
    DeleteCollage: 'delete_collage',
    EditSeries: 'edit_series',
    DeleteSeries: 'delete_series',
    RemoveTitleGroupFromSeries: 'remove_title_group_from_series',
    EditTorrentRequest: 'edit_torrent_request',
    EditForumPost: 'edit_forum_post',
    EditForumThread: 'edit_forum_thread',
    PinForumThread: 'pin_forum_thread',
    LockForumThread: 'lock_forum_thread',
    EditForumSubCategory: 'edit_forum_sub_category',
    EditForumCategory: 'edit_forum_category',
    CreateForumCategory: 'create_forum_category',
    CreateForumSubCategory: 'create_forum_sub_category',
    CreateForumThread: 'create_forum_thread',
    CreateForumPost: 'create_forum_post',
    DeleteForumCategory: 'delete_forum_category',
    DeleteForumSubCategory: 'delete_forum_sub_category',
    DeleteForumThread: 'delete_forum_thread',
    DeleteForumPost: 'delete_forum_post',
    SendPm: 'send_pm',
    CreateCssSheet: 'create_css_sheet',
    EditCssSheet: 'edit_css_sheet',
    ReadStaffPm: 'read_staff_pm',
    ReplyStaffPm: 'reply_staff_pm',
    ResolveStaffPm: 'resolve_staff_pm',
    UnresolveStaffPm: 'unresolve_staff_pm',
    DeleteTitleGroupTag: 'delete_title_group_tag',
    EditTitleGroupTag: 'edit_title_group_tag',
    DeleteTorrent: 'delete_torrent',
    SetTorrentStaffChecked: 'set_torrent_staff_checked',
    GetUserApplication: 'get_user_application',
    UpdateUserApplication: 'update_user_application',
    WarnUser: 'warn_user',
    BanUser: 'ban_user',
    EditUser: 'edit_user',
    CreateWikiArticle: 'create_wiki_article',
    EditWikiArticle: 'edit_wiki_article',
    CreateUserClass: 'create_user_class',
    EditUserClass: 'edit_user_class',
    DeleteUserClass: 'delete_user_class',
    EditUserPermissions: 'edit_user_permissions',
    LockUserClass: 'lock_user_class',
    ChangeUserClass: 'change_user_class',
    EditArcadiaSettings: 'edit_arcadia_settings',
    CreateDonation: 'create_donation',
    EditDonation: 'edit_donation',
    DeleteDonation: 'delete_donation',
    SearchDonation: 'search_donation',
    SearchUnauthorizedAccess: 'search_unauthorized_access',
    SearchUserEditChangeLogs: 'search_user_edit_change_logs',
    ViewTorrentPeers: 'view_torrent_peers',
    EditTorrentUpDownFactors: 'edit_torrent_up_down_factors',
    DeleteCollageEntry: 'delete_collage_entry',
    DeleteTorrentReport: 'delete_torrent_report',
    SeeForeignTorrentClients: 'see_foreign_torrent_clients',
    SetUserCustomTitle: 'set_user_custom_title'
} as const;

export type UserPermission = typeof UserPermission[keyof typeof UserPermission];



export const UserSearchOrderBy = {
    Username: 'username',
    CreatedAt: 'created_at',
    Uploaded: 'uploaded',
    Downloaded: 'downloaded',
    Torrents: 'torrents',
    TitleGroups: 'title_groups',
    TitleGroupComments: 'title_group_comments',
    ForumPosts: 'forum_posts',
    ForumThreads: 'forum_threads'
} as const;

export type UserSearchOrderBy = typeof UserSearchOrderBy[keyof typeof UserSearchOrderBy];


export interface UserSearchResult {
    'avatar'?: string | null;
    'banned': boolean;
    'class_name': string;
    'created_at': string;
    'downloaded': number;
    'forum_posts': number;
    'forum_threads': number;
    'id': number;
    'last_seen': string;
    'title_group_comments': number;
    'title_groups': number;
    'torrents': number;
    'uploaded': number;
    'username': string;
    'warned': boolean;
}
export interface UserSettings {
    'css_sheet_name': string;
}
export interface UserWarning {
    'ban': boolean;
    'created_at': string;
    'created_by_id': number;
    'expires_at'?: string | null;
    'id': number;
    'reason': string;
    'user_id': number;
}

export const VideoCodec = {
    Mpeg1: 'mpeg1',
    Mpeg2: 'mpeg2',
    XviD: 'XviD',
    DivX: 'DivX',
    H264: 'h264',
    H265: 'h265',
    Vc1: 'vc-1',
    Vp9: 'vp9',
    Bd50: 'BD50',
    Uhd100: 'UHD100',
    Dvd5: 'DVD5',
    Dvd9: 'DVD9',
    Vp6: 'VP6',
    Rv40: 'RV40'
} as const;

export type VideoCodec = typeof VideoCodec[keyof typeof VideoCodec];



export const VideoResolution = {
    Ntsc: 'NTSC',
    Pal: 'PAL',
    Other: 'Other',
    _360p: '360p',
    _480p: '480p',
    _480i: '480i',
    _576i: '576i',
    _576p: '576p',
    _720p: '720p',
    _1080p: '1080p',
    _1080i: '1080i',
    _1440p: '1440p',
    _2160p: '2160p',
    _4320p: '4320p'
} as const;

export type VideoResolution = typeof VideoResolution[keyof typeof VideoResolution];


export interface WarnUser200Response {
    'data': UserWarning;
    'side_effects': Array<SideEffect>;
}
export interface WikiArticle {
    'body': string;
    'created_at': string;
    'created_by_id': number;
    'id': number;
    'title': string;
    'updated_at': string;
    'updated_by_id': number;
}



export const createArtistAffiliation = async (userCreatedAffiliatedArtist: Array<UserCreatedAffiliatedArtist>, options?: RawAxiosRequestConfig): Promise<CreateArtistAffiliation200Response['data']> => {
    const response = await globalAxios.request<CreateArtistAffiliation200Response>({
        url: '/api/affiliated-artists',
        method: 'POST',
        data: userCreatedAffiliatedArtist,
        ...options
    });
    return response.data.data;
};




export const deleteArtistAffiliation = async (removeAffiliatedArtistsForm: RemoveAffiliatedArtistsForm, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/affiliated-artists',
        method: 'DELETE',
        data: removeAffiliatedArtistsForm,
        ...options
    });
    return response.data;
};






export const getArcadiaSettings = async (options?: RawAxiosRequestConfig): Promise<GetArcadiaSettings200Response['data']> => {
    const response = await globalAxios.request<GetArcadiaSettings200Response>({
        url: '/api/arcadia-settings',
        method: 'GET',
        ...options
    });
    return response.data.data;
};



export const getPublicArcadiaSettings = async (options?: RawAxiosRequestConfig): Promise<GetPublicArcadiaSettings200Response['data']> => {
    const response = await globalAxios.request<GetPublicArcadiaSettings200Response>({
        url: '/api/arcadia-settings/public',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export const updateArcadiaSettings = async (arcadiaSettings: ArcadiaSettings, options?: RawAxiosRequestConfig): Promise<GetArcadiaSettings200Response['data']> => {
    const response = await globalAxios.request<GetArcadiaSettings200Response>({
        url: '/api/arcadia-settings',
        method: 'PUT',
        data: arcadiaSettings,
        ...options
    });
    return response.data.data;
};





export const createArtists = async (userCreatedArtist: Array<UserCreatedArtist>, options?: RawAxiosRequestConfig): Promise<CreateArtists201Response['data']> => {
    const response = await globalAxios.request<CreateArtists201Response>({
        url: '/api/artists',
        method: 'POST',
        data: userCreatedArtist,
        ...options
    });
    return response.data.data;
};




export const deleteArtist = async (artistId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/artists',
        method: 'DELETE',
        params: { 'artist_id': artistId },
        ...options
    });
    return response.data;
};




export const editArtist = async (editedArtist: EditedArtist, options?: RawAxiosRequestConfig): Promise<EditArtist200Response['data']> => {
    const response = await globalAxios.request<EditArtist200Response>({
        url: '/api/artists',
        method: 'PUT',
        data: editedArtist,
        ...options
    });
    return response.data.data;
};




export const getArtistPublications = async (id: number, options?: RawAxiosRequestConfig): Promise<GetArtistPublications200Response['data']> => {
    const response = await globalAxios.request<GetArtistPublications200Response>({
        url: '/api/artists',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};





export const login = async (login: Login, options?: RawAxiosRequestConfig): Promise<Login200Response['data']> => {
    const response = await globalAxios.request<Login200Response>({
        url: '/api/auth/login',
        method: 'POST',
        data: login,
        ...options
    });
    return response.data.data;
};





export const logout = async (options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/auth/logout',
        method: 'POST',
        ...options
    });
    return response.data;
};


export const refreshToken = async (refreshToken: RefreshToken, options?: RawAxiosRequestConfig): Promise<Login200Response['data']> => {
    const response = await globalAxios.request<Login200Response>({
        url: '/api/auth/refresh-token',
        method: 'POST',
        data: refreshToken,
        ...options
    });
    return response.data.data;
};




export const register = async (register: Register, options?: RawAxiosRequestConfig): Promise<Register200Response['data']> => {
    const response = await globalAxios.request<Register200Response>({
        url: '/api/auth/register',
        method: 'POST',
        data: register,
        ...options
    });
    return response.data.data;
};





export const createTitleGroupBookmark = async (userCreatedTitleGroupBookmark: UserCreatedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<GetTitleGroupBookmark200Response['data']> => {
    const response = await globalAxios.request<GetTitleGroupBookmark200Response>({
        url: '/api/title-group-bookmarks',
        method: 'POST',
        data: userCreatedTitleGroupBookmark,
        ...options
    });
    return response.data.data;
};




export const editTitleGroupBookmark = async (editedTitleGroupBookmark: EditedTitleGroupBookmark, options?: RawAxiosRequestConfig): Promise<GetTitleGroupBookmark200Response['data']> => {
    const response = await globalAxios.request<GetTitleGroupBookmark200Response>({
        url: '/api/title-group-bookmarks',
        method: 'PUT',
        data: editedTitleGroupBookmark,
        ...options
    });
    return response.data.data;
};




export const getTitleGroupBookmark = async (id: number, options?: RawAxiosRequestConfig): Promise<GetTitleGroupBookmark200Response['data']> => {
    const response = await globalAxios.request<GetTitleGroupBookmark200Response>({
        url: '/api/title-group-bookmarks',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};




export const removeTitleGroupBookmark = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/title-group-bookmarks',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};





export const deleteCollage = async (collageId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/collages',
        method: 'DELETE',
        params: { 'collage_id': collageId },
        ...options
    });
    return response.data;
};



export interface DeleteCollageEntryRequest {
    'collage_id': number;
    'title_group_id': number;
}



export const deleteCollageEntry = async (request: DeleteCollageEntryRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/collages/entries`,
        method: 'DELETE',
        params: { 'collage_id': request['collage_id'], 'title_group_id': request['title_group_id'] },
        ...options
    });
    return response.data;
};



export const editCollage = async (editedCollage: EditedCollage, options?: RawAxiosRequestConfig): Promise<GetCollage200Response['data']> => {
    const response = await globalAxios.request<GetCollage200Response>({
        url: '/api/collages',
        method: 'PUT',
        data: editedCollage,
        ...options
    });
    return response.data.data;
};





export const createCollage = async (userCreatedCollage: UserCreatedCollage, options?: RawAxiosRequestConfig): Promise<GetCollage200Response['data']> => {
    const response = await globalAxios.request<GetCollage200Response>({
        url: '/api/collages',
        method: 'POST',
        data: userCreatedCollage,
        ...options
    });
    return response.data.data;
};




export const getCollage = async (id: number, options?: RawAxiosRequestConfig): Promise<GetCollage200Response['data']> => {
    const response = await globalAxios.request<GetCollage200Response>({
        url: '/api/collages',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};



export interface GetCollageEntriesRequest {
    'title_group_include_empty_groups': boolean;
    'page': number;
    'page_size': number;
    'order_by_column': TorrentSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'title_group_name'?: string | null;
    'title_group_content_type'?: Array<ContentType> | null;
    'title_group_category'?: Array<TitleGroupCategory> | null;
    'edition_group_source'?: Array<Source> | null;
    'torrent_video_resolution'?: Array<VideoResolution> | null;
    'torrent_language'?: Array<Language> | null;
    'torrent_reported'?: boolean | null;
    'torrent_staff_checked'?: boolean | null;
    'torrent_created_by_id'?: number | null;
    'torrent_snatched_by_id'?: number | null;
    'artist_id'?: number | null;
    'collage_id'?: number | null;
    'series_id'?: number | null;
}



export const getCollageEntries = async (request: GetCollageEntriesRequest, options?: RawAxiosRequestConfig): Promise<GetCollageEntries200Response['data']> => {
    const response = await globalAxios.request<GetCollageEntries200Response>({
        url: `/api/collages/entries`,
        method: 'GET',
        params: { 'title_group_name': request['title_group_name'], 'title_group_content_type': request['title_group_content_type'], 'title_group_category': request['title_group_category'], 'title_group_include_empty_groups': request['title_group_include_empty_groups'], 'edition_group_source': request['edition_group_source'], 'torrent_video_resolution': request['torrent_video_resolution'], 'torrent_language': request['torrent_language'], 'torrent_reported': request['torrent_reported'], 'torrent_staff_checked': request['torrent_staff_checked'], 'torrent_created_by_id': request['torrent_created_by_id'], 'torrent_snatched_by_id': request['torrent_snatched_by_id'], 'artist_id': request['artist_id'], 'collage_id': request['collage_id'], 'series_id': request['series_id'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};



export const insertsEntriesIntoACollage = async (userCreatedCollageEntry: Array<UserCreatedCollageEntry>, options?: RawAxiosRequestConfig): Promise<InsertsEntriesIntoACollage200Response['data']> => {
    const response = await globalAxios.request<InsertsEntriesIntoACollage200Response>({
        url: '/api/collages/entries',
        method: 'POST',
        data: userCreatedCollageEntry,
        ...options
    });
    return response.data.data;
};





export const createConversation = async (userCreatedConversation: UserCreatedConversation, options?: RawAxiosRequestConfig): Promise<CreateConversation200Response['data']> => {
    const response = await globalAxios.request<CreateConversation200Response>({
        url: '/api/conversations',
        method: 'POST',
        data: userCreatedConversation,
        ...options
    });
    return response.data.data;
};




export const createConversationMessage = async (userCreatedConversationMessage: UserCreatedConversationMessage, options?: RawAxiosRequestConfig): Promise<CreateConversationMessage200Response['data']> => {
    const response = await globalAxios.request<CreateConversationMessage200Response>({
        url: '/api/conversations/messages',
        method: 'POST',
        data: userCreatedConversationMessage,
        ...options
    });
    return response.data.data;
};




export const getConversation = async (id: number, options?: RawAxiosRequestConfig): Promise<GetConversation200Response['data']> => {
    const response = await globalAxios.request<GetConversation200Response>({
        url: '/api/conversations',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};





export const createCSSSheet = async (userCreatedCssSheet: UserCreatedCssSheet, options?: RawAxiosRequestConfig): Promise<EditCSSSheet200Response['data']> => {
    const response = await globalAxios.request<EditCSSSheet200Response>({
        url: '/api/css-sheets',
        method: 'POST',
        data: userCreatedCssSheet,
        ...options
    });
    return response.data.data;
};




export const editCSSSheet = async (editedCssSheet: EditedCssSheet, options?: RawAxiosRequestConfig): Promise<EditCSSSheet200Response['data']> => {
    const response = await globalAxios.request<EditCSSSheet200Response>({
        url: '/api/css-sheets',
        method: 'PUT',
        data: editedCssSheet,
        ...options
    });
    return response.data.data;
};




export const getCSSSheet = async (name: string, options?: RawAxiosRequestConfig): Promise<EditCSSSheet200Response['data']> => {
    const response = await globalAxios.request<EditCSSSheet200Response>({
        url: `/api/css-sheets/{name}`.replace('{' + 'name' + '}', String(name)),
        method: 'GET',
        ...options
    });
    return response.data.data;
};




export const getCSSSheetContent = async (name: string, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/css/{name}.css`.replace('{' + 'name' + '}', String(name)),
        method: 'GET',
        ...options
    });
    return response.data;
};





export const getCSSSheets = async (options?: RawAxiosRequestConfig): Promise<GetCSSSheets200Response['data']> => {
    const response = await globalAxios.request<GetCSSSheets200Response>({
        url: '/api/css-sheets',
        method: 'GET',
        ...options
    });
    return response.data.data;
};



export const createDonation = async (userCreatedDonation: UserCreatedDonation, options?: RawAxiosRequestConfig): Promise<EditDonation200Response['data']> => {
    const response = await globalAxios.request<EditDonation200Response>({
        url: '/api/donations',
        method: 'POST',
        data: userCreatedDonation,
        ...options
    });
    return response.data.data;
};




export const deleteDonation = async (deletedDonation: DeletedDonation, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/donations',
        method: 'DELETE',
        data: deletedDonation,
        ...options
    });
    return response.data;
};




export const editDonation = async (editedDonation: EditedDonation, options?: RawAxiosRequestConfig): Promise<EditDonation200Response['data']> => {
    const response = await globalAxios.request<EditDonation200Response>({
        url: '/api/donations',
        method: 'PUT',
        data: editedDonation,
        ...options
    });
    return response.data.data;
};



export interface SearchDonationsRequest {
    'page': number;
    'page_size': number;
    'donated_by_id'?: number | null;
    'created_by_id'?: number | null;
    'min_amount'?: number | null;
    'max_amount'?: number | null;
    'donated_at_start'?: string | null;
    'donated_at_end'?: string | null;
    'order_by_column'?: DonationOrderBy | null;
    'order_by_direction'?: OrderByDirection | null;
}



export const searchDonations = async (request: SearchDonationsRequest, options?: RawAxiosRequestConfig): Promise<SearchDonations200Response['data']> => {
    const response = await globalAxios.request<SearchDonations200Response>({
        url: `/api/donations`,
        method: 'GET',
        params: { 'donated_by_id': request['donated_by_id'], 'created_by_id': request['created_by_id'], 'min_amount': request['min_amount'], 'max_amount': request['max_amount'], 'donated_at_start': request['donated_at_start'], 'donated_at_end': request['donated_at_end'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};




export const createEditionGroup = async (userCreatedEditionGroup: UserCreatedEditionGroup, options?: RawAxiosRequestConfig): Promise<EditEditionGroup200Response['data']> => {
    const response = await globalAxios.request<EditEditionGroup200Response>({
        url: '/api/edition-groups',
        method: 'POST',
        data: userCreatedEditionGroup,
        ...options
    });
    return response.data.data;
};




export const editEditionGroup = async (editedEditionGroup: EditedEditionGroup, options?: RawAxiosRequestConfig): Promise<EditEditionGroup200Response['data']> => {
    const response = await globalAxios.request<EditEditionGroup200Response>({
        url: '/api/edition-groups',
        method: 'PUT',
        data: editedEditionGroup,
        ...options
    });
    return response.data.data;
};





export const getComicVineData = async (url: string, options?: RawAxiosRequestConfig): Promise<GetComicVineData200Response['data']> => {
    const response = await globalAxios.request<GetComicVineData200Response>({
        url: '/api/external-sources/comic-vine',
        method: 'GET',
        params: { 'url': url },
        ...options
    });
    return response.data.data;
};




export const getIsbnData = async (isbn: string, options?: RawAxiosRequestConfig): Promise<GetComicVineData200Response['data']> => {
    const response = await globalAxios.request<GetComicVineData200Response>({
        url: '/api/external-sources/isbn',
        method: 'GET',
        params: { 'isbn': isbn },
        ...options
    });
    return response.data.data;
};




export const getMusicbranzData = async (url: string, options?: RawAxiosRequestConfig): Promise<GetComicVineData200Response['data']> => {
    const response = await globalAxios.request<GetComicVineData200Response>({
        url: '/api/external-sources/musicbrainz',
        method: 'GET',
        params: { 'url': url },
        ...options
    });
    return response.data.data;
};




export const getTMDBData = async (url: string, options?: RawAxiosRequestConfig): Promise<GetComicVineData200Response['data']> => {
    const response = await globalAxios.request<GetComicVineData200Response>({
        url: '/api/external-sources/tmdb',
        method: 'GET',
        params: { 'url': url },
        ...options
    });
    return response.data.data;
};





export const addForumSubCategoryAllowedPoster = async (forumSubCategoryAllowedPoster: ForumSubCategoryAllowedPoster, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/sub-category/allowed-poster',
        method: 'POST',
        data: forumSubCategoryAllowedPoster,
        ...options
    });
    return response.data;
};




export const createForumCategory = async (userCreatedForumCategory: UserCreatedForumCategory, options?: RawAxiosRequestConfig): Promise<EditForumCategory200Response['data']> => {
    const response = await globalAxios.request<EditForumCategory200Response>({
        url: '/api/forum/category',
        method: 'POST',
        data: userCreatedForumCategory,
        ...options
    });
    return response.data.data;
};




export const createForumPost = async (userCreatedForumPost: UserCreatedForumPost, options?: RawAxiosRequestConfig): Promise<EditForumPost200Response['data']> => {
    const response = await globalAxios.request<EditForumPost200Response>({
        url: '/api/forum/post',
        method: 'POST',
        data: userCreatedForumPost,
        ...options
    });
    return response.data.data;
};




export const createForumSubCategory = async (userCreatedForumSubCategory: UserCreatedForumSubCategory, options?: RawAxiosRequestConfig): Promise<EditForumSubCategory200Response['data']> => {
    const response = await globalAxios.request<EditForumSubCategory200Response>({
        url: '/api/forum/sub-category',
        method: 'POST',
        data: userCreatedForumSubCategory,
        ...options
    });
    return response.data.data;
};




export const createForumThread = async (userCreatedForumThread: UserCreatedForumThread, options?: RawAxiosRequestConfig): Promise<CreateForumThread200Response['data']> => {
    const response = await globalAxios.request<CreateForumThread200Response>({
        url: '/api/forum/thread',
        method: 'POST',
        data: userCreatedForumThread,
        ...options
    });
    return response.data.data;
};




export const deleteForumCategory = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/category',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const deleteForumPost = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/post',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const deleteForumSubCategory = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/sub-category',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const deleteForumThread = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/thread',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const editForumCategory = async (editedForumCategory: EditedForumCategory, options?: RawAxiosRequestConfig): Promise<EditForumCategory200Response['data']> => {
    const response = await globalAxios.request<EditForumCategory200Response>({
        url: '/api/forum/category',
        method: 'PUT',
        data: editedForumCategory,
        ...options
    });
    return response.data.data;
};




export const editForumPost = async (editedForumPost: EditedForumPost, options?: RawAxiosRequestConfig): Promise<EditForumPost200Response['data']> => {
    const response = await globalAxios.request<EditForumPost200Response>({
        url: '/api/forum/post',
        method: 'PUT',
        data: editedForumPost,
        ...options
    });
    return response.data.data;
};




export const editForumSubCategory = async (editedForumSubCategory: EditedForumSubCategory, options?: RawAxiosRequestConfig): Promise<EditForumSubCategory200Response['data']> => {
    const response = await globalAxios.request<EditForumSubCategory200Response>({
        url: '/api/forum/sub-category',
        method: 'PUT',
        data: editedForumSubCategory,
        ...options
    });
    return response.data.data;
};




export const editForumThread = async (editedForumThread: EditedForumThread, options?: RawAxiosRequestConfig): Promise<GetForumThread200Response['data']> => {
    const response = await globalAxios.request<GetForumThread200Response>({
        url: '/api/forum/thread',
        method: 'PUT',
        data: editedForumThread,
        ...options
    });
    return response.data.data;
};





export const getForum = async (options?: RawAxiosRequestConfig): Promise<GetForum200Response['data']> => {
    const response = await globalAxios.request<GetForum200Response>({
        url: '/api/forum',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export const getForumSubCategoryAllowedPosters = async (forumSubCategoryId: number, options?: RawAxiosRequestConfig): Promise<GetForumSubCategoryAllowedPosters200Response['data']> => {
    const response = await globalAxios.request<GetForumSubCategoryAllowedPosters200Response>({
        url: '/api/forum/sub-category/allowed-poster',
        method: 'GET',
        params: { 'forum_sub_category_id': forumSubCategoryId },
        ...options
    });
    return response.data.data;
};




export const getForumSubCategoryThreads = async (id: number, options?: RawAxiosRequestConfig): Promise<GetForumSubCategoryThreads200Response['data']> => {
    const response = await globalAxios.request<GetForumSubCategoryThreads200Response>({
        url: '/api/forum/sub-category',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};




export const getForumThread = async (id: number, options?: RawAxiosRequestConfig): Promise<GetForumThread200Response['data']> => {
    const response = await globalAxios.request<GetForumThread200Response>({
        url: '/api/forum/thread',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};



export interface GetForumThreadsPostsRequest {
    'thread_id': number;
    'page_size': number;
    'page'?: number | null;
    'post_id'?: number | null;
}



export const getForumThreadsPosts = async (request: GetForumThreadsPostsRequest, options?: RawAxiosRequestConfig): Promise<GetForumThreadSPosts200Response['data']> => {
    const response = await globalAxios.request<GetForumThreadSPosts200Response>({
        url: `/api/forum/thread/posts`,
        method: 'GET',
        params: { 'thread_id': request['thread_id'], 'page': request['page'], 'page_size': request['page_size'], 'post_id': request['post_id'] },
        ...options
    });
    return response.data.data;
};



export const pinUnpinForumThread = async (pinForumThread: PinForumThread, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/thread/pin',
        method: 'PUT',
        data: pinForumThread,
        ...options
    });
    return response.data;
};




export const removeForumSubCategoryAllowedPoster = async (forumSubCategoryAllowedPoster: ForumSubCategoryAllowedPoster, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/forum/sub-category/allowed-poster',
        method: 'DELETE',
        data: forumSubCategoryAllowedPoster,
        ...options
    });
    return response.data;
};





export const createGift = async (userCreatedGift: UserCreatedGift, options?: RawAxiosRequestConfig): Promise<CreateGift200Response['data']> => {
    const response = await globalAxios.request<CreateGift200Response>({
        url: '/api/gifts',
        method: 'POST',
        data: userCreatedGift,
        ...options
    });
    return response.data.data;
};






export const getHomeData = async (options?: RawAxiosRequestConfig): Promise<GetHomeData200Response['data']> => {
    const response = await globalAxios.request<GetHomeData200Response>({
        url: '/api/home',
        method: 'GET',
        ...options
    });
    return response.data.data;
};



export const uploadImage = async (image: File, options?: RawAxiosRequestConfig): Promise<UploadImage200Response['data']> => {
    const response = await globalAxios.request<UploadImage200Response>({
        url: '/api/image-host/upload',
        method: 'POST',
        ...options
    });
    return response.data.data;
};





export const createInvitation = async (sentInvitation: SentInvitation, options?: RawAxiosRequestConfig): Promise<CreateInvitation200Response['data']> => {
    const response = await globalAxios.request<CreateInvitation200Response>({
        url: '/api/invitations',
        method: 'POST',
        data: sentInvitation,
        ...options
    });
    return response.data.data;
};



export interface SearchSentInvitationsRequest {
    'page': number;
    'page_size': number;
    'order_by_column': InvitationSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'receiver_username'?: string | null;
}



export const searchSentInvitations = async (request: SearchSentInvitationsRequest, options?: RawAxiosRequestConfig): Promise<SearchSentInvitations200Response['data']> => {
    const response = await globalAxios.request<SearchSentInvitations200Response>({
        url: `/api/invitations`,
        method: 'GET',
        params: { 'receiver_username': request['receiver_username'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};




export const createMasterGroup = async (userCreatedMasterGroup: UserCreatedMasterGroup, options?: RawAxiosRequestConfig): Promise<CreateMasterGroup200Response['data']> => {
    const response = await globalAxios.request<CreateMasterGroup200Response>({
        url: '/api/master-groups',
        method: 'POST',
        data: userCreatedMasterGroup,
        ...options
    });
    return response.data.data;
};





export const getNotificationsForForumThreadPosts = async (includeRead: boolean, options?: RawAxiosRequestConfig): Promise<GetNotificationsForForumThreadPosts200Response['data']> => {
    const response = await globalAxios.request<GetNotificationsForForumThreadPosts200Response>({
        url: '/api/notifications/forum-thread-posts',
        method: 'GET',
        params: { 'include_read': includeRead },
        ...options
    });
    return response.data.data;
};




export const getNotificationsForStaffPMMessages = async (includeRead: boolean, options?: RawAxiosRequestConfig): Promise<GetNotificationsForStaffPMMessages200Response['data']> => {
    const response = await globalAxios.request<GetNotificationsForStaffPMMessages200Response>({
        url: '/api/notifications/staff-pm-messages',
        method: 'GET',
        params: { 'include_read': includeRead },
        ...options
    });
    return response.data.data;
};




export const getNotificationsForTitleGroupComments = async (includeRead: boolean, options?: RawAxiosRequestConfig): Promise<GetNotificationsForTitleGroupComments200Response['data']> => {
    const response = await globalAxios.request<GetNotificationsForTitleGroupComments200Response>({
        url: '/api/notifications/title-group-comments',
        method: 'GET',
        params: { 'include_read': includeRead },
        ...options
    });
    return response.data.data;
};




export const getNotificationsForTorrentRequestComments = async (includeRead: boolean, options?: RawAxiosRequestConfig): Promise<GetNotificationsForTorrentRequestComments200Response['data']> => {
    const response = await globalAxios.request<GetNotificationsForTorrentRequestComments200Response>({
        url: '/api/notifications/torrent-request-comments',
        method: 'GET',
        params: { 'include_read': includeRead },
        ...options
    });
    return response.data.data;
};




export interface SearchArtistsRequest {
    'page': number;
    'page_size': number;
    'order_by_column': ArtistSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'name'?: string | null;
}



export const searchArtists = async (request: SearchArtistsRequest, options?: RawAxiosRequestConfig): Promise<SearchArtists200Response['data']> => {
    const response = await globalAxios.request<SearchArtists200Response>({
        url: `/api/search/artists`,
        method: 'GET',
        params: { 'name': request['name'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};



export const searchArtistsLite = async (name: string, options?: RawAxiosRequestConfig): Promise<SearchArtistsLite200Response['data']> => {
    const response = await globalAxios.request<SearchArtistsLite200Response>({
        url: '/api/search/artists/lite',
        method: 'GET',
        params: { 'name': name },
        ...options
    });
    return response.data.data;
};



export interface SearchCollagesRequest {
    'page': number;
    'page_size': number;
    'name'?: string | null;
    'tags'?: Array<string> | null;
}



export const searchCollages = async (request: SearchCollagesRequest, options?: RawAxiosRequestConfig): Promise<SearchCollages200Response['data']> => {
    const response = await globalAxios.request<SearchCollages200Response>({
        url: `/api/search/collages`,
        method: 'GET',
        params: { 'name': request['name'], 'tags': request['tags'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};


export interface SearchCollagesLiteRequest {
    'name': string;
    'results_amount': number;
}



export const searchCollagesLite = async (request: SearchCollagesLiteRequest, options?: RawAxiosRequestConfig): Promise<SearchCollagesLite200Response['data']> => {
    const response = await globalAxios.request<SearchCollagesLite200Response>({
        url: `/api/search/collages/lite`,
        method: 'GET',
        params: { 'name': request['name'], 'results_amount': request['results_amount'] },
        ...options
    });
    return response.data.data;
};


export interface SearchForumRequest {
    'page': number;
    'page_size': number;
    'thread_name'?: string | null;
}



export const searchForum = async (request: SearchForumRequest, options?: RawAxiosRequestConfig): Promise<SearchForum200Response['data']> => {
    const response = await globalAxios.request<SearchForum200Response>({
        url: `/api/search/forum`,
        method: 'GET',
        params: { 'thread_name': request['thread_name'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};


export interface SearchSeriesRequest {
    'page': number;
    'page_size': number;
    'name'?: string | null;
    'tags'?: Array<string> | null;
}



export const searchSeries = async (request: SearchSeriesRequest, options?: RawAxiosRequestConfig): Promise<SearchSeries200Response['data']> => {
    const response = await globalAxios.request<SearchSeries200Response>({
        url: `/api/search/series`,
        method: 'GET',
        params: { 'name': request['name'], 'tags': request['tags'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};



export const searchSeriesLite = async (name: string, options?: RawAxiosRequestConfig): Promise<SearchSeriesLite200Response['data']> => {
    const response = await globalAxios.request<SearchSeriesLite200Response>({
        url: '/api/search/series/lite',
        method: 'GET',
        params: { 'name': name },
        ...options
    });
    return response.data.data;
};



export interface SearchTitleGroupCommentsRequest {
    'page': number;
    'page_size': number;
    'content'?: string | null;
}



export const searchTitleGroupComments = async (request: SearchTitleGroupCommentsRequest, options?: RawAxiosRequestConfig): Promise<SearchTitleGroupComments200Response['data']> => {
    const response = await globalAxios.request<SearchTitleGroupComments200Response>({
        url: `/api/search/title-group-comments`,
        method: 'GET',
        params: { 'content': request['content'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};


export interface SearchTitleGroupInfoRequest {
    'name': string;
    'content_type'?: ContentType | null;
}



export const searchTitleGroupInfo = async (request: SearchTitleGroupInfoRequest, options?: RawAxiosRequestConfig): Promise<SearchTitleGroupInfo200Response['data']> => {
    const response = await globalAxios.request<SearchTitleGroupInfo200Response>({
        url: `/api/search/title-groups/lite`,
        method: 'GET',
        params: { 'name': request['name'], 'content_type': request['content_type'] },
        ...options
    });
    return response.data.data;
};


export interface SearchTitleGroupTagsRequest {
    'name': string;
    'page': number;
    'page_size': number;
    'order_by_column': TitleGroupTagSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
}



export const searchTitleGroupTags = async (request: SearchTitleGroupTagsRequest, options?: RawAxiosRequestConfig): Promise<SearchTitleGroupTags200Response['data']> => {
    const response = await globalAxios.request<SearchTitleGroupTags200Response>({
        url: `/api/search/title-group-tags`,
        method: 'GET',
        params: { 'name': request['name'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};


export interface SearchTitleGroupTagsLiteRequest {
    'name': string;
    'page': number;
    'page_size': number;
}



export const searchTitleGroupTagsLite = async (request: SearchTitleGroupTagsLiteRequest, options?: RawAxiosRequestConfig): Promise<SearchTitleGroupTagsLite200Response['data']> => {
    const response = await globalAxios.request<SearchTitleGroupTagsLite200Response>({
        url: `/api/search/title-group-tags/lite`,
        method: 'GET',
        params: { 'name': request['name'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};


export interface SearchTorrentRequestsRequest {
    'order_by': TorrentRequestSearchOrderBy;
    'order_by_direction': OrderByDirection;
    'include_filled': boolean;
    'title_group_name'?: string | null;
    'tags'?: Array<string> | null;
    'page'?: number | null;
    'page_size'?: number | null;
}



export const searchTorrentRequests = async (request: SearchTorrentRequestsRequest, options?: RawAxiosRequestConfig): Promise<SearchTorrentRequests200Response['data']> => {
    const response = await globalAxios.request<SearchTorrentRequests200Response>({
        url: `/api/search/torrent-requests`,
        method: 'GET',
        params: { 'title_group_name': request['title_group_name'], 'tags': request['tags'], 'order_by': request['order_by'], 'order_by_direction': request['order_by_direction'], 'include_filled': request['include_filled'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};


export interface SearchTorrentsRequest {
    'title_group_include_empty_groups': boolean;
    'page': number;
    'page_size': number;
    'order_by_column': TorrentSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'title_group_name'?: string | null;
    'title_group_content_type'?: Array<ContentType> | null;
    'title_group_category'?: Array<TitleGroupCategory> | null;
    'edition_group_source'?: Array<Source> | null;
    'torrent_video_resolution'?: Array<VideoResolution> | null;
    'torrent_language'?: Array<Language> | null;
    'torrent_reported'?: boolean | null;
    'torrent_staff_checked'?: boolean | null;
    'torrent_created_by_id'?: number | null;
    'torrent_snatched_by_id'?: number | null;
    'artist_id'?: number | null;
    'collage_id'?: number | null;
    'series_id'?: number | null;
}



export const searchTorrents = async (request: SearchTorrentsRequest, options?: RawAxiosRequestConfig): Promise<GetCollageEntries200Response['data']> => {
    const response = await globalAxios.request<GetCollageEntries200Response>({
        url: `/api/search/torrents/lite`,
        method: 'GET',
        params: { 'title_group_name': request['title_group_name'], 'title_group_content_type': request['title_group_content_type'], 'title_group_category': request['title_group_category'], 'title_group_include_empty_groups': request['title_group_include_empty_groups'], 'edition_group_source': request['edition_group_source'], 'torrent_video_resolution': request['torrent_video_resolution'], 'torrent_language': request['torrent_language'], 'torrent_reported': request['torrent_reported'], 'torrent_staff_checked': request['torrent_staff_checked'], 'torrent_created_by_id': request['torrent_created_by_id'], 'torrent_snatched_by_id': request['torrent_snatched_by_id'], 'artist_id': request['artist_id'], 'collage_id': request['collage_id'], 'series_id': request['series_id'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};


export interface SearchUsersRequest {
    'order_by': UserSearchOrderBy;
    'order_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'username'?: string | null;
}



export const searchUsers = async (request: SearchUsersRequest, options?: RawAxiosRequestConfig): Promise<SearchUsers200Response['data']> => {
    const response = await globalAxios.request<SearchUsers200Response>({
        url: `/api/search/users`,
        method: 'GET',
        params: { 'username': request['username'], 'order_by': request['order_by'], 'order_by_direction': request['order_by_direction'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};



export const searchUsersLite = async (username: string, options?: RawAxiosRequestConfig): Promise<SearchUsersLite200Response['data']> => {
    const response = await globalAxios.request<SearchUsersLite200Response>({
        url: '/api/search/users/lite',
        method: 'GET',
        params: { 'username': username },
        ...options
    });
    return response.data.data;
};





export const addTitleGroupToSeries = async (addTitleGroupToSeriesRequest: AddTitleGroupToSeriesRequest, options?: RawAxiosRequestConfig): Promise<AddTitleGroupToSeries200Response['data']> => {
    const response = await globalAxios.request<AddTitleGroupToSeries200Response>({
        url: '/api/series/title-group',
        method: 'POST',
        data: addTitleGroupToSeriesRequest,
        ...options
    });
    return response.data.data;
};




export const createSeries = async (userCreatedSeries: UserCreatedSeries, options?: RawAxiosRequestConfig): Promise<GetSeries200Response['data']> => {
    const response = await globalAxios.request<GetSeries200Response>({
        url: '/api/series',
        method: 'POST',
        data: userCreatedSeries,
        ...options
    });
    return response.data.data;
};




export const deleteSeries = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/series',
        method: 'DELETE',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const editSeries = async (editedSeries: EditedSeries, options?: RawAxiosRequestConfig): Promise<GetSeries200Response['data']> => {
    const response = await globalAxios.request<GetSeries200Response>({
        url: '/api/series',
        method: 'PUT',
        data: editedSeries,
        ...options
    });
    return response.data.data;
};




export const getSeries = async (id: number, options?: RawAxiosRequestConfig): Promise<GetSeries200Response['data']> => {
    const response = await globalAxios.request<GetSeries200Response>({
        url: '/api/series',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};



export interface GetSeriesEntriesRequest {
    'title_group_include_empty_groups': boolean;
    'page': number;
    'page_size': number;
    'order_by_column': TorrentSearchOrderByColumn;
    'order_by_direction': OrderByDirection;
    'title_group_name'?: string | null;
    'title_group_content_type'?: Array<ContentType> | null;
    'title_group_category'?: Array<TitleGroupCategory> | null;
    'edition_group_source'?: Array<Source> | null;
    'torrent_video_resolution'?: Array<VideoResolution> | null;
    'torrent_language'?: Array<Language> | null;
    'torrent_reported'?: boolean | null;
    'torrent_staff_checked'?: boolean | null;
    'torrent_created_by_id'?: number | null;
    'torrent_snatched_by_id'?: number | null;
    'artist_id'?: number | null;
    'collage_id'?: number | null;
    'series_id'?: number | null;
}



export const getSeriesEntries = async (request: GetSeriesEntriesRequest, options?: RawAxiosRequestConfig): Promise<GetCollageEntries200Response['data']> => {
    const response = await globalAxios.request<GetCollageEntries200Response>({
        url: `/api/series/entries`,
        method: 'GET',
        params: { 'title_group_name': request['title_group_name'], 'title_group_content_type': request['title_group_content_type'], 'title_group_category': request['title_group_category'], 'title_group_include_empty_groups': request['title_group_include_empty_groups'], 'edition_group_source': request['edition_group_source'], 'torrent_video_resolution': request['torrent_video_resolution'], 'torrent_language': request['torrent_language'], 'torrent_reported': request['torrent_reported'], 'torrent_staff_checked': request['torrent_staff_checked'], 'torrent_created_by_id': request['torrent_created_by_id'], 'torrent_snatched_by_id': request['torrent_snatched_by_id'], 'artist_id': request['artist_id'], 'collage_id': request['collage_id'], 'series_id': request['series_id'], 'page': request['page'], 'page_size': request['page_size'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'] },
        ...options
    });
    return response.data.data;
};



export const removeTitleGroupFromSeries = async (removeTitleGroupFromSeriesRequest: RemoveTitleGroupFromSeriesRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/series/title-group',
        method: 'DELETE',
        data: removeTitleGroupFromSeriesRequest,
        ...options
    });
    return response.data;
};





export const buyFreeleechTokens = async (buyFreeleechTokensRequest: BuyFreeleechTokensRequest, options?: RawAxiosRequestConfig): Promise<BuyFreeleechTokens201Response['data']> => {
    const response = await globalAxios.request<BuyFreeleechTokens201Response>({
        url: '/api/shop/buy-freeleech-tokens',
        method: 'POST',
        data: buyFreeleechTokensRequest,
        ...options
    });
    return response.data.data;
};





export const buyPromotion = async (options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/shop/buy-promotion',
        method: 'POST',
        ...options
    });
    return response.data;
};


export const buyUpload = async (buyUploadRequest: BuyUploadRequest, options?: RawAxiosRequestConfig): Promise<BuyFreeleechTokens201Response['data']> => {
    const response = await globalAxios.request<BuyFreeleechTokens201Response>({
        url: '/api/shop/buy-upload',
        method: 'POST',
        data: buyUploadRequest,
        ...options
    });
    return response.data.data;
};





export const getShopPricing = async (options?: RawAxiosRequestConfig): Promise<GetShopPricing200Response['data']> => {
    const response = await globalAxios.request<GetShopPricing200Response>({
        url: '/api/shop/pricing',
        method: 'GET',
        ...options
    });
    return response.data.data;
};



export const getShopPurchaseHistory = async (options?: RawAxiosRequestConfig): Promise<GetShopPurchaseHistory200Response['data']> => {
    const response = await globalAxios.request<GetShopPurchaseHistory200Response>({
        url: '/api/shop/history',
        method: 'GET',
        ...options
    });
    return response.data.data;
};



export const createStaffPM = async (userCreatedStaffPm: UserCreatedStaffPm, options?: RawAxiosRequestConfig): Promise<CreateStaffPM201Response['data']> => {
    const response = await globalAxios.request<CreateStaffPM201Response>({
        url: '/api/staff-pms',
        method: 'POST',
        data: userCreatedStaffPm,
        ...options
    });
    return response.data.data;
};




export const createStaffPMMessage = async (userCreatedStaffPmMessage: UserCreatedStaffPmMessage, options?: RawAxiosRequestConfig): Promise<CreateStaffPMMessage201Response['data']> => {
    const response = await globalAxios.request<CreateStaffPMMessage201Response>({
        url: '/api/staff-pms/messages',
        method: 'POST',
        data: userCreatedStaffPmMessage,
        ...options
    });
    return response.data.data;
};




export const getStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<GetStaffPM200Response['data']> => {
    const response = await globalAxios.request<GetStaffPM200Response>({
        url: `/api/staff-pms/{id}`.replace('{' + 'id' + '}', String(id)),
        method: 'GET',
        ...options
    });
    return response.data.data;
};





export const listStaffPMs = async (options?: RawAxiosRequestConfig): Promise<ListStaffPMs200Response['data']> => {
    const response = await globalAxios.request<ListStaffPMs200Response>({
        url: '/api/staff-pms',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export const resolveStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<CreateStaffPM201Response['data']> => {
    const response = await globalAxios.request<CreateStaffPM201Response>({
        url: `/api/staff-pms/{id}/resolve`.replace('{' + 'id' + '}', String(id)),
        method: 'PUT',
        ...options
    });
    return response.data.data;
};




export const unresolveStaffPM = async (id: number, options?: RawAxiosRequestConfig): Promise<CreateStaffPM201Response['data']> => {
    const response = await globalAxios.request<CreateStaffPM201Response>({
        url: `/api/staff-pms/{id}/unresolve`.replace('{' + 'id' + '}', String(id)),
        method: 'PUT',
        ...options
    });
    return response.data.data;
};




export interface GetTorrentStatsRequest {
    'from': string;
    'to': string;
    'interval': StatsInterval;
    'group_by': TorrentStatsGroupBy;
}



export const getTorrentStats = async (request: GetTorrentStatsRequest, options?: RawAxiosRequestConfig): Promise<GetTorrentStats200Response['data']> => {
    const response = await globalAxios.request<GetTorrentStats200Response>({
        url: `/api/stats/torrents`,
        method: 'GET',
        params: { 'from': request['from'], 'to': request['to'], 'interval': request['interval'], 'group_by': request['group_by'] },
        ...options
    });
    return response.data.data;
};




export const createForumThreadPostsSubscription = async (threadId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/forum-thread-posts',
        method: 'POST',
        params: { 'thread_id': threadId },
        ...options
    });
    return response.data;
};




export const createTitleGroupCommentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/title-group-comments',
        method: 'POST',
        params: { 'title_group_id': titleGroupId },
        ...options
    });
    return response.data;
};




export const createTitleGroupTorrentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/title-group-torrents',
        method: 'POST',
        params: { 'title_group_id': titleGroupId },
        ...options
    });
    return response.data;
};




export const createTorrentRequestCommentsSubscription = async (torrentRequestId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/torrent-request-comments',
        method: 'POST',
        params: { 'torrent_request_id': torrentRequestId },
        ...options
    });
    return response.data;
};




export const removeForumThreadPostsSubscription = async (threadId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/forum-thread-posts',
        method: 'DELETE',
        params: { 'thread_id': threadId },
        ...options
    });
    return response.data;
};




export const removeTitleGroupCommentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/title-group-comments',
        method: 'DELETE',
        params: { 'title_group_id': titleGroupId },
        ...options
    });
    return response.data;
};




export const removeTitleGroupTorrentsSubscription = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/title-group-torrents',
        method: 'DELETE',
        params: { 'title_group_id': titleGroupId },
        ...options
    });
    return response.data;
};




export const removeTorrentRequestCommentsSubscription = async (torrentRequestId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/subscriptions/torrent-request-comments',
        method: 'DELETE',
        params: { 'torrent_request_id': torrentRequestId },
        ...options
    });
    return response.data;
};





export const createTitleGroup = async (userCreatedTitleGroup: UserCreatedTitleGroup, options?: RawAxiosRequestConfig): Promise<AddTitleGroupToSeries200Response['data']> => {
    const response = await globalAxios.request<AddTitleGroupToSeries200Response>({
        url: '/api/title-groups',
        method: 'POST',
        data: userCreatedTitleGroup,
        ...options
    });
    return response.data.data;
};




export const createTitleGroupComment = async (userCreatedTitleGroupComment: UserCreatedTitleGroupComment, options?: RawAxiosRequestConfig): Promise<CreateTitleGroupComment200Response['data']> => {
    const response = await globalAxios.request<CreateTitleGroupComment200Response>({
        url: '/api/title-groups/comments',
        method: 'POST',
        data: userCreatedTitleGroupComment,
        ...options
    });
    return response.data.data;
};




export const deleteTitleGroup = async (titleGroupId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/title-groups',
        method: 'DELETE',
        params: { 'title_group_id': titleGroupId },
        ...options
    });
    return response.data;
};




export const editTitleGroup = async (editedTitleGroup: EditedTitleGroup, options?: RawAxiosRequestConfig): Promise<AddTitleGroupToSeries200Response['data']> => {
    const response = await globalAxios.request<AddTitleGroupToSeries200Response>({
        url: '/api/title-groups',
        method: 'PUT',
        data: editedTitleGroup,
        ...options
    });
    return response.data.data;
};



export interface EditTitleGroupCommentRequest {
    'id': number;
    'EditedTitleGroupComment': EditedTitleGroupComment;
}



export const editTitleGroupComment = async (request: EditTitleGroupCommentRequest, options?: RawAxiosRequestConfig): Promise<CreateTitleGroupComment200Response['data']> => {
    const response = await globalAxios.request<CreateTitleGroupComment200Response>({
        url: `/api/title-groups/comments/{id}`.replace('{' + 'id' + '}', String(request['id'])),
        method: 'PUT',
        data: request['EditedTitleGroupComment'],
        ...options
    });
    return response.data.data;
};



export const getTitleGroup = async (id: number, options?: RawAxiosRequestConfig): Promise<GetTitleGroup200Response['data']> => {
    const response = await globalAxios.request<GetTitleGroup200Response>({
        url: '/api/title-groups',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};




export const getTitleGroupInfoLite = async (id: number, options?: RawAxiosRequestConfig): Promise<GetTitleGroupInfoLite200Response['data']> => {
    const response = await globalAxios.request<GetTitleGroupInfoLite200Response>({
        url: '/api/title-groups/lite',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};





export const applyTagToTitleGroup = async (appliedTitleGroupTag: AppliedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/title-group-tags/apply',
        method: 'POST',
        data: appliedTitleGroupTag,
        ...options
    });
    return response.data;
};




export const createTitleGroupTag = async (userCreatedTitleGroupTag: UserCreatedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<EditTitleGroupTag200Response['data']> => {
    const response = await globalAxios.request<EditTitleGroupTag200Response>({
        url: '/api/title-group-tags',
        method: 'POST',
        data: userCreatedTitleGroupTag,
        ...options
    });
    return response.data.data;
};




export const deleteTitleGroupTag = async (deleteTagRequest: DeleteTagRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/title-group-tags',
        method: 'DELETE',
        data: deleteTagRequest,
        ...options
    });
    return response.data;
};




export const editTitleGroupTag = async (editedTitleGroupTag: EditedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<EditTitleGroupTag200Response['data']> => {
    const response = await globalAxios.request<EditTitleGroupTag200Response>({
        url: '/api/title-group-tags',
        method: 'PUT',
        data: editedTitleGroupTag,
        ...options
    });
    return response.data.data;
};




export const removeTagFromTitleGroup = async (removedTitleGroupTag: RemovedTitleGroupTag, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/title-group-tags/remove',
        method: 'DELETE',
        data: removedTitleGroupTag,
        ...options
    });
    return response.data;
};




export interface CreateTorrentRequest {
    'audio_bitrate': number;
    'audio_bitrate_sampling': AudioBitrateSampling;
    'audio_channels': string;
    'audio_codec': AudioCodec;
    'bonus_points_snatch_cost': number;
    'container': string;
    'description': string;
    'duration': number;
    'edition_group_id': number;
    'extras': string;
    'features': string;
    'languages': string;
    'mediainfo': string;
    'release_group': string;
    'release_name': string;
    'subtitle_languages': string;
    'torrent_file': File;
    'trumpable': string;
    'uploaded_as_anonymous': boolean;
    'video_codec': VideoCodec;
    'video_resolution': VideoResolution;
    'video_resolution_other_x': number;
    'video_resolution_other_y': number;
}



export const createTorrent = async (request: CreateTorrentRequest, options?: RawAxiosRequestConfig): Promise<EditTorrent200Response['data']> => {
    const response = await globalAxios.request<EditTorrent200Response>({
        url: `/api/torrents`,
        method: 'POST',
        ...options
    });
    return response.data.data;
};



export const createTorrentReport = async (userCreatedTorrentReport: UserCreatedTorrentReport, options?: RawAxiosRequestConfig): Promise<CreateTorrentReport200Response['data']> => {
    const response = await globalAxios.request<CreateTorrentReport200Response>({
        url: '/api/torrents/reports',
        method: 'POST',
        data: userCreatedTorrentReport,
        ...options
    });
    return response.data.data;
};




export const deleteTorrent = async (torrentToDelete: TorrentToDelete, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/torrents',
        method: 'DELETE',
        data: torrentToDelete,
        ...options
    });
    return response.data;
};




export const deleteTorrentReport = async (torrentReportId: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/torrents/reports',
        method: 'DELETE',
        params: { 'torrent_report_id': torrentReportId },
        ...options
    });
    return response.data;
};




export const downloadTorrentFile = async (id: number, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/torrents',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data;
};




export const editTorrent = async (editedTorrent: EditedTorrent, options?: RawAxiosRequestConfig): Promise<EditTorrent200Response['data']> => {
    const response = await globalAxios.request<EditTorrent200Response>({
        url: '/api/torrents',
        method: 'PUT',
        data: editedTorrent,
        ...options
    });
    return response.data.data;
};




export const editTorrentUploadDownloadFactors = async (editTorrentUpDownFactors: EditTorrentUpDownFactors, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/torrents/up-down-factors',
        method: 'PUT',
        data: editTorrentUpDownFactors,
        ...options
    });
    return response.data;
};



export interface GetTopTorrentRequest {
    'period': string;
    'amount': number;
}



export const getTopTorrent = async (request: GetTopTorrentRequest, options?: RawAxiosRequestConfig): Promise<GetTopTorrent200Response['data']> => {
    const response = await globalAxios.request<GetTopTorrent200Response>({
        url: `/api/torrents/top`,
        method: 'GET',
        params: { 'period': request['period'], 'amount': request['amount'] },
        ...options
    });
    return response.data.data;
};



export const getTorrentPeers = async (torrentId: number, options?: RawAxiosRequestConfig): Promise<GetTorrentPeers200Response['data']> => {
    const response = await globalAxios.request<GetTorrentPeers200Response>({
        url: '/api/torrents/peers',
        method: 'GET',
        params: { 'torrent_id': torrentId },
        ...options
    });
    return response.data.data;
};




export const getTorrentTitleGroupId = async (torrentId: number, options?: RawAxiosRequestConfig): Promise<GetTorrentTitleGroupId200Response['data']> => {
    const response = await globalAxios.request<GetTorrentTitleGroupId200Response>({
        url: '/api/torrents/title-group-id',
        method: 'GET',
        params: { 'torrent_id': torrentId },
        ...options
    });
    return response.data.data;
};





export const getUploadInformation = async (options?: RawAxiosRequestConfig): Promise<GetUploadInformation200Response['data']> => {
    const response = await globalAxios.request<GetUploadInformation200Response>({
        url: '/api/torrents/upload-info',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export const setTorrentStaffChecked = async (setTorrentStaffChecked: SetTorrentStaffChecked, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/torrents/staff-checked',
        method: 'PUT',
        data: setTorrentStaffChecked,
        ...options
    });
    return response.data;
};





export const createTorrentRequest = async (userCreatedTorrentRequest: UserCreatedTorrentRequest, options?: RawAxiosRequestConfig): Promise<CreateTorrentRequest200Response['data']> => {
    const response = await globalAxios.request<CreateTorrentRequest200Response>({
        url: '/api/torrent-requests',
        method: 'POST',
        data: userCreatedTorrentRequest,
        ...options
    });
    return response.data.data;
};




export const createTorrentRequestComment = async (userCreatedTorrentRequestComment: UserCreatedTorrentRequestComment, options?: RawAxiosRequestConfig): Promise<CreateTorrentRequestComment201Response['data']> => {
    const response = await globalAxios.request<CreateTorrentRequestComment201Response>({
        url: '/api/torrent-requests/comment',
        method: 'POST',
        data: userCreatedTorrentRequestComment,
        ...options
    });
    return response.data.data;
};




export const createTorrentRequestVote = async (userCreatedTorrentRequestVote: UserCreatedTorrentRequestVote, options?: RawAxiosRequestConfig): Promise<CreateTorrentRequestVote200Response['data']> => {
    const response = await globalAxios.request<CreateTorrentRequestVote200Response>({
        url: '/api/torrent-requests/vote',
        method: 'POST',
        data: userCreatedTorrentRequestVote,
        ...options
    });
    return response.data.data;
};




export const fillTorrentRequest = async (torrentRequestFill: TorrentRequestFill, options?: RawAxiosRequestConfig): Promise<FillTorrentRequest200Response['data']> => {
    const response = await globalAxios.request<FillTorrentRequest200Response>({
        url: '/api/torrent-requests/fill',
        method: 'POST',
        data: torrentRequestFill,
        ...options
    });
    return response.data.data;
};




export const getTorrentRequest = async (id: number, options?: RawAxiosRequestConfig): Promise<GetTorrentRequest200Response['data']> => {
    const response = await globalAxios.request<GetTorrentRequest200Response>({
        url: '/api/torrent-requests',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};




export interface SearchUnauthorizedAccessLogsRequest {
    'from_date': string;
    'to_date': string;
    'sort_by_column': UnauthorizedAccessSortByColumn;
    'sort_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'user_id'?: number | null;
    'permission'?: UserPermission | null;
}



export const searchUnauthorizedAccessLogs = async (request: SearchUnauthorizedAccessLogsRequest, options?: RawAxiosRequestConfig): Promise<SearchUnauthorizedAccessLogs200Response['data']> => {
    const response = await globalAxios.request<SearchUnauthorizedAccessLogs200Response>({
        url: `/api/unauthorized-access`,
        method: 'GET',
        params: { 'user_id': request['user_id'], 'from_date': request['from_date'], 'to_date': request['to_date'], 'permission': request['permission'], 'sort_by_column': request['sort_by_column'], 'sort_by_direction': request['sort_by_direction'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};



export interface ChangeUserClassRequest {
    'id': number;
    'UserClassChange': UserClassChange;
}



export const changeUserClass = async (request: ChangeUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/users/{id}/class`.replace('{' + 'id' + '}', String(request['id'])),
        method: 'PUT',
        data: request['UserClassChange'],
        ...options
    });
    return response.data;
};



export const editUser = async (editedUser: EditedUser, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/users',
        method: 'PUT',
        data: editedUser,
        ...options
    });
    return response.data;
};



export interface EditUserPermissionsRequest {
    'id': number;
    'UpdatedUserPermissions': UpdatedUserPermissions;
}



export const editUserPermissions = async (request: EditUserPermissionsRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/users/{id}/permissions`.replace('{' + 'id' + '}', String(request['id'])),
        method: 'PUT',
        data: request['UpdatedUserPermissions'],
        ...options
    });
    return response.data;
};




export const getMe = async (options?: RawAxiosRequestConfig): Promise<GetMe200Response['data']> => {
    const response = await globalAxios.request<GetMe200Response>({
        url: '/api/users/me',
        method: 'GET',
        ...options
    });
    return response.data.data;
};

export interface GetTorrentActivitiesOverviewRequest {
    'hours_seeding_per_day': number;
    'seeders_per_torrent': SeedersPerTorrent;
}



export const getTorrentActivitiesOverview = async (request: GetTorrentActivitiesOverviewRequest, options?: RawAxiosRequestConfig): Promise<GetTorrentActivitiesOverview200Response['data']> => {
    const response = await globalAxios.request<GetTorrentActivitiesOverview200Response>({
        url: `/api/users/torrent-activities/overview`,
        method: 'GET',
        params: { 'hours_seeding_per_day': request['hours_seeding_per_day'], 'seeders_per_torrent': request['seeders_per_torrent'] },
        ...options
    });
    return response.data.data;
};



export const getUser = async (id: number, options?: RawAxiosRequestConfig): Promise<GetUser200Response['data']> => {
    const response = await globalAxios.request<GetUser200Response>({
        url: '/api/users',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};





export const getUserConversations = async (options?: RawAxiosRequestConfig): Promise<GetUserConversations200Response['data']> => {
    const response = await globalAxios.request<GetUserConversations200Response>({
        url: '/api/users/conversations',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export const getUserPermissions = async (id: number, options?: RawAxiosRequestConfig): Promise<GetUserPermissions200Response['data']> => {
    const response = await globalAxios.request<GetUserPermissions200Response>({
        url: `/api/users/{id}/permissions`.replace('{' + 'id' + '}', String(id)),
        method: 'GET',
        ...options
    });
    return response.data.data;
};





export const getUserSettings = async (options?: RawAxiosRequestConfig): Promise<GetUserSettings200Response['data']> => {
    const response = await globalAxios.request<GetUserSettings200Response>({
        url: '/api/users/settings',
        method: 'GET',
        ...options
    });
    return response.data.data;
};

export interface GetUserTorrentActivitiesRequest {
    'page': number;
    'page_size': number;
    'include_unseeded_torrents': boolean;
    'order_by_column': TorrentActivityOrderByColumn;
    'order_by_direction': OrderByDirection;
    'hours_seeding_per_day': number;
    'seeders_per_torrent': SeedersPerTorrent;
}



export const getUserTorrentActivities = async (request: GetUserTorrentActivitiesRequest, options?: RawAxiosRequestConfig): Promise<GetUserTorrentActivities200Response['data']> => {
    const response = await globalAxios.request<GetUserTorrentActivities200Response>({
        url: `/api/users/torrent-activities`,
        method: 'GET',
        params: { 'page': request['page'], 'page_size': request['page_size'], 'include_unseeded_torrents': request['include_unseeded_torrents'], 'order_by_column': request['order_by_column'], 'order_by_direction': request['order_by_direction'], 'hours_seeding_per_day': request['hours_seeding_per_day'], 'seeders_per_torrent': request['seeders_per_torrent'] },
        ...options
    });
    return response.data.data;
};


export interface LockUnlockUserClassRequest {
    'id': number;
    'UserClassLockStatus': UserClassLockStatus;
}



export const lockUnlockUserClass = async (request: LockUnlockUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/users/{id}/lock-class`.replace('{' + 'id' + '}', String(request['id'])),
        method: 'PUT',
        data: request['UserClassLockStatus'],
        ...options
    });
    return response.data;
};


export interface SetUserCustomTitleRequest {
    'id': number;
    'UpdateUserCustomTitle': UpdateUserCustomTitle;
}



export const setUserCustomTitle = async (request: SetUserCustomTitleRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/users/{id}/custom-title`.replace('{' + 'id' + '}', String(request['id'])),
        method: 'PUT',
        data: request['UpdateUserCustomTitle'],
        ...options
    });
    return response.data;
};



export const updateUserSettings = async (userSettings: UserSettings, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: '/api/users/settings',
        method: 'PUT',
        data: userSettings,
        ...options
    });
    return response.data;
};




export const warnUser = async (userCreatedUserWarning: UserCreatedUserWarning, options?: RawAxiosRequestConfig): Promise<WarnUser200Response['data']> => {
    const response = await globalAxios.request<WarnUser200Response>({
        url: '/api/users/warn',
        method: 'POST',
        data: userCreatedUserWarning,
        ...options
    });
    return response.data.data;
};





export const createUserApplication = async (userCreatedUserApplication: UserCreatedUserApplication, options?: RawAxiosRequestConfig): Promise<CreateUserApplication201Response['data']> => {
    const response = await globalAxios.request<CreateUserApplication201Response>({
        url: '/api/auth/apply',
        method: 'POST',
        data: userCreatedUserApplication,
        ...options
    });
    return response.data.data;
};



export interface GetUserApplicationsRequest {
    'page_size'?: number | null;
    'page'?: number | null;
    'status'?: string | null;
}



export const getUserApplications = async (request: GetUserApplicationsRequest, options?: RawAxiosRequestConfig): Promise<GetUserApplications200Response['data']> => {
    const response = await globalAxios.request<GetUserApplications200Response>({
        url: `/api/user-applications`,
        method: 'GET',
        params: { 'page_size': request['page_size'], 'page': request['page'], 'status': request['status'] },
        ...options
    });
    return response.data.data;
};



export const updateUserApplicationStatus = async (updateUserApplication: UpdateUserApplication, options?: RawAxiosRequestConfig): Promise<CreateUserApplication201Response['data']> => {
    const response = await globalAxios.request<CreateUserApplication201Response>({
        url: '/api/user-applications',
        method: 'PUT',
        data: updateUserApplication,
        ...options
    });
    return response.data.data;
};





export const createUserClass = async (userCreatedUserClass: UserCreatedUserClass, options?: RawAxiosRequestConfig): Promise<CreateUserClass201Response['data']> => {
    const response = await globalAxios.request<CreateUserClass201Response>({
        url: '/api/user-classes',
        method: 'POST',
        data: userCreatedUserClass,
        ...options
    });
    return response.data.data;
};



export interface DeleteUserClassRequest {
    'name': string;
    'DeleteUserClass': DeleteUserClass;
}



export const deleteUserClass = async (request: DeleteUserClassRequest, options?: RawAxiosRequestConfig): Promise<void> => {
    const response = await globalAxios.request<void>({
        url: `/api/user-classes/{name}`.replace('{' + 'name' + '}', String(request['name'])),
        method: 'DELETE',
        data: request['DeleteUserClass'],
        ...options
    });
    return response.data;
};


export interface EditUserClassRequest {
    'name': string;
    'EditedUserClass': EditedUserClass;
}



export const editUserClass = async (request: EditUserClassRequest, options?: RawAxiosRequestConfig): Promise<CreateUserClass201Response['data']> => {
    const response = await globalAxios.request<CreateUserClass201Response>({
        url: `/api/user-classes/{name}`.replace('{' + 'name' + '}', String(request['name'])),
        method: 'PUT',
        data: request['EditedUserClass'],
        ...options
    });
    return response.data.data;
};




export const getAllUserClasses = async (options?: RawAxiosRequestConfig): Promise<GetAllUserClasses200Response['data']> => {
    const response = await globalAxios.request<GetAllUserClasses200Response>({
        url: '/api/user-classes',
        method: 'GET',
        ...options
    });
    return response.data.data;
};


export interface SearchUserEditChangeLogsRequest {
    'sort_by_column': UserEditChangeLogSortByColumn;
    'sort_by_direction': OrderByDirection;
    'page': number;
    'page_size': number;
    'user_id'?: number | null;
    'item_type'?: string | null;
}



export const searchUserEditChangeLogs = async (request: SearchUserEditChangeLogsRequest, options?: RawAxiosRequestConfig): Promise<SearchUserEditChangeLogs200Response['data']> => {
    const response = await globalAxios.request<SearchUserEditChangeLogs200Response>({
        url: `/api/user-edit-change-logs`,
        method: 'GET',
        params: { 'user_id': request['user_id'], 'item_type': request['item_type'], 'sort_by_column': request['sort_by_column'], 'sort_by_direction': request['sort_by_direction'], 'page': request['page'], 'page_size': request['page_size'] },
        ...options
    });
    return response.data.data;
};




export const createWikiArticle = async (userCreatedWikiArticle: UserCreatedWikiArticle, options?: RawAxiosRequestConfig): Promise<GetWikiArticle200Response['data']> => {
    const response = await globalAxios.request<GetWikiArticle200Response>({
        url: '/api/wiki/articles',
        method: 'POST',
        data: userCreatedWikiArticle,
        ...options
    });
    return response.data.data;
};




export const editWikiArticle = async (editedWikiArticle: EditedWikiArticle, options?: RawAxiosRequestConfig): Promise<GetWikiArticle200Response['data']> => {
    const response = await globalAxios.request<GetWikiArticle200Response>({
        url: '/api/wiki/articles',
        method: 'PUT',
        data: editedWikiArticle,
        ...options
    });
    return response.data.data;
};




export const getWikiArticle = async (id: number, options?: RawAxiosRequestConfig): Promise<GetWikiArticle200Response['data']> => {
    const response = await globalAxios.request<GetWikiArticle200Response>({
        url: '/api/wiki/articles',
        method: 'GET',
        params: { 'id': id },
        ...options
    });
    return response.data.data;
};



